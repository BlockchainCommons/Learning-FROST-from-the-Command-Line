{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#part-one-learning-about-frost","title":"Part One: Learning about FROST","text":"<ul> <li>1.0: Introduction to FROST</li> </ul>"},{"location":"#part-two-frost-from-the-command-line","title":"Part Two: FROST from the Command Line","text":"<ul> <li>2.0: Signing with FROST</li> <li>3.0: Advanced FROST Capabilities </li> <li>4.0: Using FROST with Bitcoin</li> </ul>"},{"location":"#video-overview-of-course","title":"Video Overview of Course","text":"<p>This course is built from GitHub. You can read there if you prefer. A grant for the creation of this course was provided by HRF.</p>"},{"location":"01_0_Introduction/","title":"Chapter One: Introduction to FROST","text":"<p>What is FROST? How does it compare to traditional multisig or secret sharding systems? And what is Schnorr and how do the two major Schnorr designs, FROST and MuSig2, compare?</p> <p>Those are the topics of this chapter, which are intended to help anyone, including engineers, developers, and project managers, to understand the fundamentals of the new FROST threshold signing system.</p>"},{"location":"01_0_Introduction/#objectives-for-this-chapter","title":"Objectives for this Chapter","text":"<p>After working through this chapter, a reader will be able to:</p> <ul> <li>Decide to Implement FROST (or Not)</li> </ul> <p>Supporting objectives include the ability to:</p> <ul> <li>Know the Fundamental Properties of FROST</li> <li>Understand the Process of FROST Signing</li> <li>Understand the Differences between FROST and Other Systems</li> </ul>"},{"location":"01_0_Introduction/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Section One: Introducing FROST</li> <li>Section Two: The FROST Signature Process</li> <li>Section Three: FROST vs MuSig2</li> </ul>"},{"location":"01_1_Introducing_FROST/","title":"1.1: Introducing FROST","text":"<p>FROST stands for Flexible Round-Optimized Schnorr Threshold Signatures. As the name indicates, it's a style of Schnorr signature that supports M of N threshold signatures. Though there is a 2020 paper by Chelsea Komlo and Ian Goldberg that gives all the specifics, this section is intended to offer a more accessible introduction to the technology.</p>"},{"location":"01_1_Introducing_FROST/#the-power-of-frost","title":"The Power of FROST","text":"<p>FROST is a threshold signature scheme. That means that a group of participants each hold a share of a private key. The private key does not exist in full, but only in those parts. The shares can be used collectively to create signatures for the private key, with only a \"threshold\" of shares required to generate the signature.</p> <p>This threshold is determined when the key is generated. It might be the whole group of signers or some smaller number. Common thresholds include \"1 of 2\", \"2 of 3\", and \"3 of 5\". These mean that one out of two shares is required to sign, or two out of three, or three out of five, respectively.</p> <p>There is also a public key, which does exist in full, and can be used to verify signatures made by the private key shares. It's sometimes called a group verifying key.</p> <p>:book: What is a Public Key? A public key is a publicly distributed cryptographic code that might act as an address or an identifier. It is generated from a private key and can be used to verify signatures made by the private key.</p> <p>:book: What is a Private Key? A private key is a secret cryptographic code. It is often used to digitally sign things. Doing so can prove that the owner controls a specific public key.</p> <p>:book: What is a Share? A key can be sharded with a system such as Shamir's Secret Sharing. This generates a set of \"n\" shares. The original key can then be reconstructed from \"m\" of the shares where \"m\u2264n\", but if fewer than \"m\" of the shares are brought together, they tell nothing about the secret. These shares can also be used for Schnorr signing schemes such as FROST, without the need to bring them together.</p> <p>:book: What is VSS? VSS, or Verifiable Secret Sharing, is a variant of Shamir's Secret Sharing. It allows the verification of shares, so that recipients know they actually define a secret, which is crucial to some FROST methods of key generation. (VSS shares can also prove the continued existence of the shares without actually revealing them, which is great for secret resilience, but less important for FROST itself.)</p> <p>Beyond being a threshold signature system, FROST is also a Schnorr signature system, which refers to the exact process (algorithm) used to generate the digital signature. Schnorr has some advantages over traditional signatures related to privacy and efficiency, as discussed below.</p>"},{"location":"01_1_Introducing_FROST/#frost-without-the-math","title":"FROST without the Math","text":"<p>The FROST signature scheme has two main elements: signature share generation and signing.</p>"},{"location":"01_1_Introducing_FROST/#frost-signature-share-generation-without-the-math","title":"Frost Signature Share Generation without the Math","text":"<p>First, the members of a FROST group must generate shares of a private key that they will then use to sign messages. They do so by first determining the number of group members and the threshold required for signing, and then engaging in a key-generation ceremony. This can be done in one of two ways:</p> <p>Trusted Dealer Generation (TDG): This is a traditional method. One trusted, centralized server generates a private key (or is given a key), shards it, and sends out the shares to the members of the FROST group. The disadvantage of TDG is that the server must be very trusted, and the key exists in a single place for at least some time, allowing it to potentially be stolen.</p> <p>Distributed Key Generation (DKG): This is a more secure, but also newer and more complex method. It takes advantage of Secure Multi-Party Computing (MPC) and VSS. The members of the FROST group work together to generate their shares of the private key, with each member creating their personal share over the course of the ceremony, but with the combined private key never coming into existence, and no member ever learning any share but their own.</p> <p>Whichever way the individual shares are generated, the key-generation ceremony will also create a combined public key (\"group verifying key\") that can be used to verify signatures made by the private key shares.</p>"},{"location":"01_1_Introducing_FROST/#frost-signing-without-the-math","title":"Frost Signing without the Math","text":"<p>Once the members of FROST group have created their signing shares, they can then sign. This is done by creating a commitment to a nonce, then creating a signature. Again, there are two ways to do this:</p> <p>Pre-Processing: Each member of the FROST group generates a set of nonces and a set of commitments for those nonces and stores the commitments on a centralized server. The signing process can then be done in a single-round signing process</p> <p>Two-Round Process: The members of the FROST group engage in a first round to generate nonces (which they hold) and commtiments (which they share), and then a second round to generate the signature. This makes the process more complex, but removes the dependence on a centralized server.</p> <p>The signing process is usually overseen by a signature aggregator (or coordinator) who passes everything to the participants without having any special privileges. Again, this literal middle-man can be cut out if desired, in which case all elements of the signing process must be broadcast in a secure way.</p> <p>The next chapter, \u00a71.2: The FROST Signature Process, details these specifics in more detail. The original paper, \"FROST: Flexible Round-Optimized Schnorr Threshold Signatures\", by Chelsea Komlo and Ian Goldberg, may be consulted for even more specifics. But you only need to know enough to be comfortable with using FROST! So dive only as deep you like; just be sure that you're comfortable with the difference between TDG and DKG and the fact that key shares are first generated and then used for signing.</p>"},{"location":"01_1_Introducing_FROST/#the-usage-of-frost","title":"The Usage of FROST","text":"<p>So why would you use FROST? Threshold signatures have generally been used to give a group of people control over cryptocurrencies. However, FROST threshold signatures can also be used to authenticate any consensus protocol. It could allow a board of directors to sign off on directives for their organization, or a set of members to make decisions for a DAO.</p> <p>Generally, if you have a group of people and you want to get permission from either the whole group or alternatively some subset, then a threshold signature is the way to go.</p>"},{"location":"01_1_Introducing_FROST/#the-advantages-of-frost","title":"The Advantages of FROST","text":"<p>FROST has a number of advantages that set it aside from classic threshold signature systems, such as Bitcoin's multisig. Some of these are due to the use of Schnorr signatures, some of them are due to the specific design of FROST.</p> <p>Small Signatures. FROST signatures are aggregateable: the individual signatures are effectively added together. As a result, the final multi-signature is the same size as a single signature! This makes it much smaller than most traditional multisigs, which instead require each and every participant to append their signature to an ever-growing message. That means that very large thresholds (say, 101 of 200, to represent consensus for a group) are easy under FROST, where they were totally unfeasible under traditional systems.</p> <p>Private Signatures. You can't distinguish between a single signature and a multi-signature. It's not just that they're the same size, but also that they look just the same. This makes FROST signatures much more private because a third party doesn't know if a signature represents a single individual or multiple individuals. And if it's multiple individuals, the third party does know which members of the FROST group contributed to the threshold.</p> <p>Efficient Communication. FROST was built specifically to make the signing process simple and efficient. When pre-processing is used to register commitments in advance, signing can be done in a single round: signers can act asynchronously and all each needs to do is reply to a single message to create a signature. This lowers network load and makes threshold signatures possible on network-limited devices. It also allows for use cases where some participants are offline or airgapped, increasing security.</p> <p>Repair &amp; Refresh Capabilities. FROST shares can be repaired (allowing the recovery of lost shares or the creation of new shares) or refreshed (allowing the changing of current shares). This not only allows the shares to change over time, but also allows the threshold to change. A 2 of 3 threshold could, for example, become a 3 of 5 with a few repair operations. (However, it should be noted, that old shares and even old participants still remain trusted by the FROST group; if this doesn't match the reality of a situation, then a FROST group needs to be entirely replaced with a new one.)</p> <p>Strong Security with DKG. If DKG is used, the private key never exists in a single place. This provides very strong security because there is no Single Point of Compromise (SPOC) if the threshold is 2 or greater. Instead, an attacker would have to steal multiple shares from multiple locations.</p> <p>The biggest trade-off for all of these advantages is a reduction in robustness. Some existing threshold signature systems are better at keep malicious actors from censoring (blocking) the use of a multisig. FROST can still do so, but only by recognizing a bad actor and purposefully excluding them from the process. A wrapper called ROAST can resolve the issue of robustness, but it's not necessary in many use cases.</p>"},{"location":"01_1_Introducing_FROST/#using-frost","title":"Using FROST","text":"<p>FROST can be used anywhere that you need to make a signature.</p> <p>This tutorial focused on the ZF FROST project that was initiated by the Zcash Foundation, but which has wide applicability. (It's not just for Zcash.)</p> <p>They have a Rust FROST library implementation, which supports several different ciphersuites using either TDG or DGK.</p> <p>They also have CLI tools to demo FROST that are used in this tutorial (along with some of our own tweaks and the Bitcoin Dev Kit.</p>"},{"location":"01_1_Introducing_FROST/#summary-introducing-frost","title":"Summary: Introducing FROST","text":"<p>FROST is a threshold signature system built using Schnorr signatures. It is intended to be more efficient than other similar protocols by minimizing the number of rounds of communication required for signatures. It also has advantages in size, efficiency, and privacy and provides additional capabilities because it can rewrite thresholds and groups after the fact.</p>"},{"location":"01_1_Introducing_FROST/#whats-next","title":"What's Next","text":"<p>Continue your \"Introduction to FROST\" by learning some of the specifics of how FROST works in \"\u00a71.2: The FROST Signature Process\".</p> <p>Or, if you don't need those specifics, consider reading about the underlying Schnorr signature system in \u00a71.3: FROST vs MuSig2.</p> <p>Or, if you've seen enough about the nuts and bolts, jump straight to Chapter Two: Signing with FROST for the hands-on tutorial.</p>"},{"location":"01_2_FROST_Signature_Process/","title":"1.2: The FROST Signature Process","text":"<p>So how does FROST actually work? This section describes the process for both methods of key generation and both methods of signing, without delving into the mathematical specifics. Read as much of it as you find useful: the important thing is just understanding the generalities.</p> <p>For more of the math, see the 2020 FROST paper and one of its foundations, Genarro et. al.'s \"Secure Distributed Key Generation for Discrete-Log Based Cryptosystems\".</p>"},{"location":"01_2_FROST_Signature_Process/#the-key-generation-process","title":"The Key Generation Process","text":"<p>There are two major methods by which FROST keys can be created: Trusted Dealer Generation (TDG) and Distributed Key Generation (DKG). The first is simpler, the second is more secure.</p>"},{"location":"01_2_FROST_Signature_Process/#the-trusted-dealer-generation-tdg-process","title":"The Trusted Dealer Generation (TDG) Process","text":"<p>TDG depends on a naive security assumption: trust in a centralized server. The TDG process is equally naive and simple. It creates a key and shards it with Shamir's Secret Sharding before sharing out the shards:</p> <ol> <li>Trusted Dealer creates private key.</li> <li>Trusted Dealer shards private key for \"n\" members with a threshold of \"m\".</li> <li>Trusted Dealer sends private key shares &amp; group verifying key to FROST group members.</li> <li>Trusted Dealer (hopefully) erases secret &amp; shares.</li> </ol> <p> </p> <p>The secret could also be generated in other ways, such as a member creating the secret and handing it to the dealer for distribution.</p>"},{"location":"01_2_FROST_Signature_Process/#the-distributed-key-generation-dkg-process","title":"The Distributed Key Generation (DKG) Process","text":"<p>The FROST paper suggests PedPoP for Distributed Key Generation (DKG) in FROST: Pedersen DKG with Proofs of Possession, which is Torben Pedersen's DKG system as modified by Rosario Gennaro and others to support Verifiable Secret Sharing (VSS). But since, more variants have been offered, such as ChillDKG, which further modifies PedPoP into SimplPedPop, simplifying PedPoP and also making it more securely usable with Bitcoin Taproot.</p> <p>:warning: WARNING: The lesson here is that DKG is not fully defined for use with FROST. There are a number of different DKG methodologies that could be used. They're all legitimate as long as they generate a set of key shares in a distributed manner that is secure for your security assumptions.</p> <p>The specifics likely don't manner to you if you're using a library or CLI that has already determined how to generate its shares using DKG. However, here's the general process utilized by the ZF FROST package that's used in this tutorial. It's laid out as \"inputs\" to the ZF FROST software, \"outputs\" from the ZF FROST software, and \"transmits\" among members.</p> <p>Prep:</p> <ol> <li>Via some means, the participants agree on member count (\"n\") and threshold (\"m\") for the signature (an \"m of n\" threshold signature).</li> </ol> <p>Round 1:</p> <ol> <li>Each member inputs their identifier, member count (\"n\") and threshold (\"m\").</li> <li>Each member outputs public data and secret data.</li> <li>Secret data includes two polynomials, which contain the member's secret.</li> <li>Public data is a commitment to that secret, in the form of a Pedersen-VSS share.</li> <li>Each member transmits their public data to all other members via a broadcast.</li> <li>At this point, the joint secret has been fixed.</li> </ol> <p>Round 2:</p> <ol> <li>Each member inputs their secret data from round 1 and the public data from all the other members from round 1, keyed to the identifier for each member.</li> <li>Each member outputs a second set of secret data.</li> <li>Secret data now includes the member's share of the joint secret: their private key share.</li> <li>Each member outputs response data for each other member.</li> <li>Response data includes a commitment using Feldmann-VSS.</li> <li>Each members transmits the response data to each other member via an authenticated and encrypted personal communication channel.</li> </ol> <p>Post:</p> <ol> <li>Each members inputs their second set of secret data, the public data from all other members received at the start of Round 2, and the response packages received back from all members at the end of Round 2.</li> <li>Each member outputs their share of the private key and the full group verifying key.</li> </ol> <p> </p>"},{"location":"01_2_FROST_Signature_Process/#the-signing-process","title":"The Signing Process","text":"<p>Signing with FROST is a two-round process, but the first round can be pre-processed to lower overhead at signing time.</p>"},{"location":"01_2_FROST_Signature_Process/#the-two-round-process","title":"The Two-Round Process","text":"<p>The two-round FROST signature process is best described in \u00a75 of RFC 9591. Round 1 is commitment and round two is signing. A signing coordinator is involved in the process by default: they don't have any special authority or knowledge, but they do take care of the logistics, and as a result could censor the process if they wanted.</p> <p>Round 1:</p> <ol> <li>Each member creates two nonces and commitments to those nonces.</li> <li>Each member transmits the commitments to the coordinator.</li> </ol> <p>Round 2:</p> <ol> <li>Coordinator transmits message to chosen members to sign.</li> <li>Coordinator transmits relevant commitments to chosen members.</li> <li>Each member checks this information.</li> <li>Each member uses their secret key share and nonce to sign.</li> <li>Each member transmits the resultant signature share to coordinator.</li> <li>Each member deletes the nonce used and corresponding commitment.</li> </ol> <p>Post:</p> <ol> <li>Coordinator checks signature shares.</li> <li>Coordinator aggregates signature shares to produce signature.</li> </ol> <p> </p>"},{"location":"01_2_FROST_Signature_Process/#the-pre-processed-process","title":"The Pre-Processed Process","text":"<p>FROST signatures can occur in a single round if the nonces and signatures are preprocessed:</p> <p>Preprocessing:</p> <ol> <li>Each member generates a list of several nonces and commitments.</li> <li>Each member publishes their commitments in some way.</li> </ol> <p>Round 1:</p> <ol> <li>Coordinator selects next commitments from list for chosen members.</li> <li>Coordinator transmits message to chosen members to sign.</li> <li>Coordinator transmits relevant commitments to chosen members.</li> <li>Each member checks this information.</li> <li>Each member uses their secret key share and nonce to sign.</li> <li>Each member transmits the resultant signature share to coordinator.</li> <li>Each member deletes the nonce used and corresponding commitment.</li> </ol> <p>Post:</p> <ol> <li>Coordinator checks signature shares.</li> <li>Coordinator aggregates signature shares to produce signature.</li> </ol> <p> </p> <p>Algorithmically, there is no difference between the two-round and pre-processing variants of FROST signatures. It's simply a question of whether the nonces and commitments are generated and stored in advance (pre-processing) or generated on the fly (two-round).</p>"},{"location":"01_2_FROST_Signature_Process/#summary-the-frost-signature-process","title":"Summary: The FROST Signature Process","text":"<p>There are two ways to create FROST private key shares: through a standard use of Shamir's Secret Sharing or through a more complex Distributed Key Generation sequence that may vary from one FROST library to another.</p> <p>There are two ways to sign with FROST: through a two-round process or through an equivalent process where the first-round has been pre-processed and stored.</p> <p>You likely don't need to know the specifics of how each works, but you should understand the two main variations for key generation and signing, so that you can recognize the options offered to your by various libraries.</p>"},{"location":"01_2_FROST_Signature_Process/#whats-next","title":"What's Next","text":"<p>Continue your \"Introduction to FROST\" by learning more about the underlaying Schnorr signing system and the biggest competitor to FROST in \u00a71.3: FROST vs MuSig2.</p> <p>Or, if you've seen enough about the nuts and bolts, jump straight to Chapter Two: Signing with FROST for the hands-on tutorial.</p>"},{"location":"01_3_FROST_vs_MuSig/","title":"1.3: FROST vs MuSig2","text":"<p>FROST combines Schnorr signatures, various DKG methods, and a specific signing protocol to create a powerful threshold signing system. This section offers some more details on the underlying Schnorr signature system and also compares FROST to the other major Schnorr signing system, MuSig2.</p>"},{"location":"01_3_FROST_vs_MuSig/#the-power-of-schnorr","title":"The Power of Schnorr","text":"<p>FROST defines a methodology for using private key shares to generate signing shares that can then be aggregated into a single signature. The full private key is never reconstructed in the process. The ability to sign and aggregate in this way comes from the Schnorr signature algorithm that is the heart of FROST.</p> <p>:book: What is a Schnorr signature? A Schnorr signature is a digital signature based on Claus Schnorr's signature algorithm. It was under patent until 2010, which resulted in other algorithms such as RSA and ECDSA being used, even by those who considered them inferior to Schnorr signatures. Schnorr signatures are based on the discrete log problem over finite fields rather than on elliptic curves or prime numbers, but that (along with the precise math) are details that aren't necessary for understanding FROST.</p> <p>:book: What is the security level of a Schnorr signature? Traditionally, a Schnorr signature has been understood to require a 4t-bit security level: 128 bits of security require a 512 bit signature. More recent work has suggested that a 3t-bit security level may be sufficient.</p> <p>The biggest advantage of Schnorr signatures over other signature systems is that they're aggregateable. If you have a signature A and a signature B, you can add them together to create a new signature AB that is the same size as A or B. This is particularly notable when multiple parties are signing multisigs or threshold signatures, where the signature will verify when enough people have signed it. This creates some of the advantages that were mentioned in \u00a71.1.</p> <ul> <li>Small Signatures. Schnorr Signatures are always the same size, no matter how many are aggregated into a threshold or multisig.</li> <li>Private Signatures. When a threshold signature is created using Schnorr, you can't tell who's actually signed it, just that it's valid!</li> </ul> <p>The aggregatability of Schnorr allows for the creation of adaptor signatures where a signature is \"tweaked\" by adding some secret value to it. The tweaked signature can be verified, but the secret value must be revealed to make the signature valid.</p> <p>It also allows for the creation of blind signatures, where someone can sign something without knowing its content. (This is obviously something that must be done with real care, but there are nonethless use cases for it.)</p> <p>Beyond the various advantages related to its aggregatability, Schnorr also has advantages of simplicity (the math is straightforward), linearity (aggregatability means the signatures simply add and subtract), and scalability (courtesy of the compact signatures).</p> <p>:book: How Does Schnorr Integrate with Bitcoin? Schnorr signatures were introduced to Bitcoin with block 709,632, mined on November 12th, 2021. The details of the integration of Schnorr signatures with Bitcoin can be found in BIP 340. Taproot and Tapscript, which support Schnorr, were adopted at the same time.</p> <p>Though Schnorr is the heart of FROST, FROST isn't the only way to take advantage of Schnorr.</p>"},{"location":"01_3_FROST_vs_MuSig/#the-power-of-musig","title":"The Power of MuSig","text":"<p>The main alternative to FROST is MuSig, an alternative Schnorr signing protocol that now exists in its second major incarnation, called MuSig2.</p> <p>:book: What is MuSig? MuSig is a Schnorr-based multisignature protocol designed by Gregory Maxwell, Andrew Poelstra, Yannick Seurin, and Pieter Wuille that creates aggregatable signatures that are simpler and more efficient than traditional ECDSA multsigs.</p> <p>:book: What is MuSig2? MuSig was originally released as a three-round protocol. When it was revamped into a second version, MuSig2, the number of signing rounds was reduced to two. A further variant called MuSig-DN protects against a specific sort of attack.</p> <p>The biggest difference between FROST and MuSig is that FROST is natively a threshold signature system (m of n where m\u2264n) while MuSig is by default a multisig signature system (n of n), with threshold signatures only accessible through the construction of Merkle trees where each leaf holding a different n-of-n signature.</p> <p>The other big difference between the two is on the question of privacy. The privacy of FROST means that you have deniability: it's impossible to see who signed an m-of-n threshold signature unless multiple parties conspire to reveal information. In contrast, MuSig has accountability: even if using a Merkle Tree to mimic a threshold signature, you can always see exactly who signed.</p> <p>Here's a chart of the major differences:</p> FROST MuSig2 Signature Type Threshold (m-of-n) Multisig (n-of-n) Signer Privacy Deniable Accountable Bitcoin Integration Usable Integrated Signing Rounds 2 or Preprocess 2 <p>Generally, you might use FROST for situations focused on threshold signing and MuSig2 for Schnorr-based signatures on Bitcoin (though this tutorial will demonstrate how to do FROST signing of Bitcoin transactions).</p>"},{"location":"01_3_FROST_vs_MuSig/#summary-the-frost-signature-process","title":"Summary: The FROST Signature Process","text":"<p>FROST is built on Schnorr, a powerful signature system whose biggest advantage is aggregation, which allows the addition of signatures to create combined signatures that are indistinguisable from single signatures.</p> <p>MuSig2 is another major signature protocol that also uses Schnorr. MuSig's biggest difference is that it's not a threshold system, though thresholds can be modeled by the use of Merkle trees. FROST is likely a better choice if you require threshold signatures, while MuSig2 might get the nod for Bitcoin integration.</p>"},{"location":"01_3_FROST_vs_MuSig/#whats-next","title":"What's Next","text":"<p>You're ready to begin the hands-on tutorial! Continue onward to Chapter Two: Signing with FROST to beginn experimenting with FROST tools.</p>"},{"location":"02_0_Signing_with_FROST/","title":"Chapter Two: Signing with FROST","text":"<p>The Zcash Foundation has created one of the most advanced developer resources for FROST. They've published a set of Rust crates implementing FROST with a variety of ciphersuites as well as a set of CLI tools.</p> <p>This chapter details how to use the ZF FROST command-line tools to create FROST secret shares and to sign with them using the basic Trusted Dealer methodology.</p>"},{"location":"02_0_Signing_with_FROST/#objectives-for-this-chapter","title":"Objectives for this Chapter","text":"<p>After working through this chapter, a reader will be able to:</p> <ul> <li>Create TDG FROST Secret Shares</li> <li>Use FROST Secret Shares for Signing</li> <li>Check FROST Signatures</li> </ul> <p>Supporting objectives include the ability to:</p> <ul> <li>Understand the Communication Process for FROST Signing</li> </ul>"},{"location":"02_0_Signing_with_FROST/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Section One: Installing the FROST Tools</li> <li>Section Two: Creating Trusted Dealer Shares with TDG</li> <li>Section Three: Creating a FROST Signature</li> <li>Section Four: Checking a FROST Signature</li> </ul>"},{"location":"02_1_Installing_FROST_Tools/","title":"2.1: Installing the FROST Tools","text":"<p>The ZF FROST Tools allow you to create FROST secret shares and to sign with FROST. This chapter provides hands-on tutorials for using them. By following these tutorials, you can solidfy your understanding of how FROST works.</p> <p>As demonstrated here, these tools allow the simple signing of documents, but you won't be able to Bitcoin transactions yet. That will require additional support, as detailed in Chapter 4.</p>"},{"location":"02_1_Installing_FROST_Tools/#installing-rust","title":"Installing Rust","text":"<p>The ZF Frost Tools were built with Rust using Cargo. If you've already installed Rust and Cargo on your system, you can continue on to \"Installing ZF FROST Tools\". Otherwise, you'll need to install Rust and Cargo first.</p> <p>:book: What is a Rust? Rust is a programming language focused on performance and memory safety. Its speed and efficiency and tight control over memory management have made it a favorite among developers.</p> <p>:book: What is Cargo? Cargo is Rust's package management system. It makes it simple to accurately install Rust projects ... such as the FROST Tools. (Cargo is another reason for Rust's popularity.)</p>"},{"location":"02_1_Installing_FROST_Tools/#installing-with-rustup","title":"Installing with Rustup","text":"<p>The preferred method of installing Rust and Cargo is <code>rustup</code>.</p>"},{"location":"02_1_Installing_FROST_Tools/#installing-with-rustup-on-linux-macos","title":"Installing with Rustup on Linux &amp; MacOS","text":"<p>On MacOS, Linux, and other UNIX OSes, you can run the following to install <code>rustup</code>:</p> <pre><code>% curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> <p>You should choose to \"Proceed with standard installation\". Afterward, you will need to restart your command-line shell before <code>cargo</code> will be visible.</p>"},{"location":"02_1_Installing_FROST_Tools/#installing-with-rustup-on-windows","title":"Installing with Rustup on Windows","text":"<p>A <code>rustup-init.exe</code> installer is available if you run WIndows.</p>"},{"location":"02_1_Installing_FROST_Tools/#installing-with-package-managers","title":"Installing with Package Managers","text":"<p>You can alternatively install Rust and Cargo with a standard package manager. You might prefer this if you use a single package manager to control most of your third-party installations. Rust is supported on Chocolatey, Homebrew, MacPorts, pkgsrc, and Scoop.</p>"},{"location":"02_1_Installing_FROST_Tools/#testing-your-install","title":"Testing Your Install","text":"<p>When your install is complete, you should see <code>cargo</code> in your standard path.</p> <p>This is an example of a <code>rustup</code> install:</p> <pre><code>% which cargo\n/Users/shannona/.cargo/bin/cargo\n</code></pre> <p>This is an example of a Homebrew install:</p> <pre><code>% which cargo\n/opt/homebrew/bin/cargo\n</code></pre>"},{"location":"02_1_Installing_FROST_Tools/#installing-zf-frost-tools","title":"Installing ZF FROST Tools","text":"<p>The ZF FROST Tools should be installed with <code>git</code>. If you do not have <code>git</code> installed, visit the Git Downloads site.</p> <p>Once you have <code>git</code>, choose a directory where you want to install <code>frost-tools</code> and then clone the repository:</p> <pre><code>% git clone https://github.com/ZcashFoundation/frost-tools.git\nCloning into 'frost-tools'...\nremote: Enumerating objects: 3295, done.\nremote: Counting objects: 100% (54/54), done.\nremote: Compressing objects: 100% (51/51), done.\nremote: Total 3295 (delta 25), reused 3 (delta 3), pack-reused 3241 (from 2)\nReceiving objects: 100% (3295/3295), 1.08 MiB | 1.37 MiB/s, done.\nResolving deltas: 100% (1987/1987), done.\n</code></pre> <p>This should create a <code>frost-tools</code> directory:</p> <pre><code>% ls frost-tools \nCargo.lock      frost-client        README.md\nCargo.toml      frostd          rust-toolchain.toml\ncodecov.yml     LICENSE-APACHE      supply-chain\nCONTRIBUTING.md     LICENSE-MIT     tests\nDEVELOPER.md        Makefile.toml       zcash-sign\n</code></pre> <p>You can then change into the crate root and run <code>cargo install</code>. You'll initially be installing the <code>frost-client</code> package.</p> <pre><code>% cd frost-tools\n% cargo install --path frost-client  \n</code></pre> <p>You should see the client-side ZF FROST Tools installed:</p> <pre><code>Installed package `frost-client v0.1.0 (/Users/ShannonA/Documents/GitHub/FROST/frost-tools/frost-client)` (executables `coordinator`, `dkg`, `frost-client`, `participant`, `trusted-dealer`)\n</code></pre> <p>You're now ready to use the ZF FROST Tools!</p>"},{"location":"02_1_Installing_FROST_Tools/#summary-installing-the-frost-tools","title":"Summary: Installing the FROST Tools","text":"<p>All you need to do to start using the ZF FROST Tools is to <code>clone</code> the <code>frost-tools</code> repo and build it with Rust. If you've never used Git or Rust before, you will need to download that software first.</p>"},{"location":"02_1_Installing_FROST_Tools/#whats-next","title":"What's Next","text":"<p>Continue onward with \"Signing with FROST\" by \u00a72.2: Creating FROST Secret Shares with TDG.</p>"},{"location":"02_2_Creating_FROST_Secret_Shares_with_TDG/","title":"2.2: Creating FROST Secret Shares with TDG","text":"<p>The ZF FROST Tools allow for the easy creation of FROST secret shares using either the Trusted Dealer Generation (TDG) or the Distributed Key Generation (DKG) methodology. Of these, TDG is the quickest and simplest. (DKG generation will be covered in Chapter 3.)</p>"},{"location":"02_2_Creating_FROST_Secret_Shares_with_TDG/#creating-tdg-shares","title":"Creating TDG Shares","text":"<p>Trusted Dealer Generation (TDG) can be conducted using the ZF FROST <code>trusted-dealer</code> binary, which should now be in your <code>.cargo/bin</code> directory.</p> <p>:book: What is TDG? In Trusted Dealer Generation, a single server shards a secret (which it may create itself or import) and distributes the secret shares to signers.</p> <p>:book: How Do the ZF FROST Tools Support TDG? The <code>trusted-dealer</code> binary in the ZF FROST tools can import a key or create its own. It will then generate <code>n+1</code> files: one file for each signer, containing an identifier, secret share, and commitment (which verifies the secret share); and one global file, containing the verifying key and each of the verifying shares. It is up to the user running the TDG to actually distribute the shares.</p> <p>The <code>trusted-dealer</code> binary may be run with the following flags:</p> Flag Description Default Options -C Ciphersuite ed25519 redpallas --cli Interactive -k Key Filenames key-package-{}.json --key Secret for Splitting -n Maximum Signers 3 2+ &amp; t+ -P Public Key Filename public-key-package.json -t Threshold Signers 2 2+ <p><code>trusted-dealer</code> will usually be run with the <code>-t</code> and <code>-n</code> arguments. The following uses them to create a default 2-of-3 secret share:</p> <pre><code>% trusted-dealer -t 2 -n 3 Generating 3 shares with threshold 2...\nPublic key package written to public-key-package.json\nKey package for participant\n0100000000000000000000000000000000000000000000000000000000000000\nwritten to key-package-1.json\nKey package for participant\n0200000000000000000000000000000000000000000000000000000000000000\nwritten to key-package-2.json\nKey package for participant\n0300000000000000000000000000000000000000000000000000000000000000\nwritten to key-package-3.json\n</code></pre> <p>All of the key material is stored as four files that it generates:</p> <pre><code>% ls\nkey-package-1.json  key-package-3.json\nkey-package-2.json  public-key-package.json\n</code></pre> <p>The <code>public-key-package.json</code> has all the verifying information:</p> <pre><code>{\n  \"header\": {\n    \"version\": 0,\n    \"ciphersuite\": \"FROST-ED25519-SHA512-v1\"\n  },\n  \"verifying_shares\": {\n    \"0100000000000000000000000000000000000000000000000000000000000000\": \"b496e15c0cd0438440b9890348155eb8d8616e2a3ec8815100aa0c18822ba924\",\n    \"0200000000000000000000000000000000000000000000000000000000000000\": \"68befcb80ac14775e602245a209f45c7a41dc740aeb066eb43a9f1e636ab3482\",\n    \"0300000000000000000000000000000000000000000000000000000000000000\": \"d764598583ebc633689d7819d56aa449bd280a32cc1f63c586d5036da24454a1\"\n  },\n  \"verifying_key\": \"8f9ee5e7f2642ed8b7c4eb1c7342ecbf69e7284b07e18434e577ad580a1412ed\"\n}\n</code></pre> <p>The <code>key-package-#.json</code> files each contain the secret share for one user:</p> <pre><code>{\n  \"header\": {\n    \"version\": 0,\n    \"ciphersuite\": \"FROST-ED25519-SHA512-v1\"\n  },\n  \"identifier\": \"0100000000000000000000000000000000000000000000000000000000000000\",\n  \"signing_share\": \"e958bbfac93847ee2b444a62541f75e37316d988728382d1f923c0d95c86de0d\",\n  \"commitment\": [\n    \"8f9ee5e7f2642ed8b7c4eb1c7342ecbf69e7284b07e18434e577ad580a1412ed\",\n    \"e18234fd12212514e53e4b20c34f104bc5ef84fff3a8ac5673133dd3d766b329\"\n  ]\n}\n</code></pre> <p>Each user should be sent their own <code>key-package</code> file as well as the <code>public-key-package</code>.</p> <pre><code>% secure-send alice@crypto-example.com &lt; key-package-1.json public-key-package.json\n% secure-send bob@crypto-example.com &lt; key-package-2.json public-key-package.json\n% secure-send carol@crypto-example.com &lt; key-package-3.json public-key-package.json\n</code></pre> <p>Afterward, all of the files should be securely deleted from the Trusted Dealer: though the shares were generated in a single place, they should never be available in a single place again, to take full advantage of the security of FROST signing.</p>"},{"location":"02_2_Creating_FROST_Secret_Shares_with_TDG/#summary-creating-frost-secret-shares-with-tdg","title":"Summary: Creating FROST Secret Shares with TDG","text":"<p>Trusted Dealer Generation is the simplest but also least secure way to use FROST. It allows quick and easy generation of secret shares, but the Trusted Dealer must actually be trusted and it must be secure, as it represents a Single Point of Compromise (SPOC) until the shares have been distributed and securely removed.</p> <p>(Nonetheless, it's a great way to get a first hint at how FROST works.)</p>"},{"location":"02_2_Creating_FROST_Secret_Shares_with_TDG/#whats-next","title":"What's Next","text":"<p>Continue onward with \"Signing with FROST\" by \u00a72.3: Creating a FROST Signature.</p>"},{"location":"02_3_Creating_FROST_Signature/","title":"2.3: Creating a FROST Signature","text":"<p>With their signing shares in hand, members are now ready to sign documents.</p>"},{"location":"02_3_Creating_FROST_Signature/#choosing-what-to-sign","title":"Choosing What to Sign","text":"<p>Obviously, signers need something to sign. In Chapter 4, this will be a Bitcoin transaction. Signing transfers of digital assets are a common use case for FROST signatures.</p> <p>However, you can sign anything that requires the collaborative authorization of the secret share holders. That might frequently include the validation of decisions made by a board of directors or other organization:</p> <pre><code>% cat &gt; board-meeting-250917.txt\nDate: 9/17/25\nPresent: 0100000000000000000000000000000000000000000000000000000000000000, 0200000000000000000000000000000000000000000000000000000000000000\n\nDecisions:\n* Allocate $10 to Jam in Central Park Party\n* All Members Must Contribute $5 to Group Kitty by 9/24/25\n</code></pre>"},{"location":"02_3_Creating_FROST_Signature/#signing-with-a-coordinator","title":"Signing with a Coordinator","text":"<p>FROST signing usually requires a coordinator. In the case of the ZF FROST Tools, that's the <code>coordinator</code> app. It also needs a way for the group members to connect with the <code>coordinator</code>. In the ZF FROST Tools, that's done with the <code>participant</code> app. Both should have been installed when you ran the <code>cargo install</code> for the <code>frost-client</code> package.</p> <p>The <code>coordinator</code> app may be run with the following flags as options:</p> Flag Description Default Options -C Ciphersuite ed25519 redpallas --cli Interactive -i IP Address 0.0.0.0 -m Message -n Participants -P Public Key Filename public-key-package.json -p Port 443 -r Randomizers -S Signers -s Signature Output File <p>:warning: WARNING: In our testing, the <code>participant</code>/<code>coordinator</code> connection was not always reliable. This seems to be even more the case when the <code>coordinator</code> is run with the HTTP options (allowing the setting of a non-localhost IP address). As a result, all examples are run on localhost, even though that's not the best real-world option. Even with that setup, the <code>participant</code> program sometimes did not deliver commitments when initially run, in which case <code>participant</code> was shut down (^C) and restarted.</p> <p>The following command will start <code>coordinator</code> on <code>localhost:443</code>. It will require two signatures to sign <code>board-meeting-250917.txt</code> and place the signature in <code>board-meeting-250917.sig</code>:</p> <pre><code>% coordinator -m board-meeting-250917.txt -s board-meeting-250917.sig -n 2\n</code></pre>"},{"location":"02_3_Creating_FROST_Signature/#round-1-commitments","title":"Round 1: Commitments","text":"<p>Each of the members of the FROST group who will be signing can then start the <code>participant</code> app using the <code>-k</code> flag to designate their <code>key-package</code>:</p> <pre><code>% participant -k key-package-1.json\nReading key package from key-package-1.json\nConnected to server at [1.R.0] 127.0.0.1:443\n</code></pre> <p>This will connect them to the server and send a commitment, which is round 1 of the FROST signing protocol (and the round that can be pre-computed, but is not here).</p> <p>When the commitment is correctly sent, the following will show up on the <code>coordinator</code>:</p> <pre><code>Client connected\nReceived: {\"IdentifiedCommitments\":{\"identifier\":\"0100000000000000000000000000000000000000000000000000000000000000\",\"commitments\":{\"header\":{\"version\":0,\"ciphersuite\":\"FROST-ED25519-SHA512-v1\"},\"hiding\":\"0ea60b77708bb6157f206e107db8cd85a0fbb2fa02e5b56ad178b6349895d383\",\"binding\":\"21b2994fa1e3034f65c6dc167369f69a9fc41e93cc7f70a5b417fccb82faabc7\"}}}\n\n</code></pre> <p>:warning: WARNING: If the <code>participant</code> did not correctly send the commitment to the <code>coordinator</code>, you'll see the \"Client Connected\" message, but not \"Received\". In this case, you should break out (^C) and restart <code>participant</code> for that user. You will see <code>Client connected</code>, then <code>Client disconnected</code>.</p> <p>Additional members may connect until you've met your threshold:</p> <pre><code>% participant -k key-package-2.json\n\nReceived: {\"IdentifiedCommitments\":{\"identifier\":\"0200000000000000000000000000000000000000000000000000000000000000\",\"commitments\":{\"header\":{\"version\":0,\"ciphersuite\":\"FROST-ED25519-SHA512-v1\"},\"hiding\":\"d9525e2bef65a4ed45437ecefeefa7b5054199474e2089748bfbf921c150e9d0\",\"binding\":\"106a9587b07faec2cca0c2f060644ef0f8f8b8d4f08e6c5afdc414cdfe44286a\"}}}\n\n</code></pre>"},{"location":"02_3_Creating_FROST_Signature/#round-2-signing","title":"Round 2: Signing","text":"<p>At this point, the <code>coordinator</code> will have received all the commtiments and will initiate round 2 of the FROST protocol by sending the message and commitments to the members, each of whom can choose to sign:</p> <pre><code>Sending SigningPackage to participants...\nWaiting for participants to send their SignatureShares...\n</code></pre> <p>Each group member will see something like the following:</p> <pre><code>Received: {\"SigningPackageAndRandomizer\":{\"signing_package\":{\"header\":{\"version\":0,\"ciphersuite\":\"FROST-ED25519-SHA512-v1\"},\"signing_commitments\":{\"0100000000000000000000000000000000000000000000000000000000000000\":{\"header\":{\"version\":0,\"ciphersuite\":\"FROST-ED25519-SHA512-v1\"},\"hiding\":\"0ea60b77708bb6157f206e107db8cd85a0fbb2fa02e5b56ad178b6349895d383\",\"binding\":\"21b2994fa1e3034f65c6dc167369f69a9fc41e93cc7f70a5b417fccb82faabc7\"},\"0200000000000000000000000000000000000000000000000000000000000000\":{\"header\":{\"version\":0,\"ciphersuite\":\"FROST-ED25519-SHA512-v1\"},\"hiding\":\"d9525e2bef65a4ed45437ecefeefa7b5054199474e2089748bfbf921c150e9d0\",\"binding\":\"106a9587b07faec2cca0c2f060644ef0f8f8b8d4f08e6c5afdc414cdfe44286a\"}},\"message\":\"446174653a20392f31372f32350a50726573656e743a20303130303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030302c20303230303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030300a0a4465636973696f6e733a0a2a20416c6c6f636174652024313020746f204a616d20696e2043656e7472616c205061726b2050617274790a2a20416c6c204d656d62657273204d75737420436f6e7472696275746520243520746f2047726f7570204b6974747920627920392f32342f32350a\"},\"randomizer\":null}}\nMessage to be signed (hex-encoded):\n446174653a20392f31372f32350a50726573656e743a20303130303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030302c20303230303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030300a0a4465636973696f6e733a0a2a20416c6c6f636174652024313020746f204a616d20696e2043656e7472616c205061726b2050617274790a2a20416c6c204d656d62657273204d75737420436f6e7472696275746520243520746f2047726f7570204b6974747920627920392f32342f32350a\n</code></pre>"},{"location":"02_3_Creating_FROST_Signature/#checking-your-message","title":"Checking Your Message","text":"<p>But that message (displayed in \"Message to be signed (hex-encoded):\") doesn't look anything like the text file of your minutes! That's because it's been converted to hex, which is typical for digital signing.</p> <p>You can (and should!) check the message before you sign it. This is done with <code>xxd -r -p</code>, which will convert hex to ASCII. You just need to copy out the \"Message to be signed (hex-encoded):\" and run it through <code>xxd</code>:</p> <pre><code>% echo \"446174653a20392f31372f32350a50726573656e743a20303130303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030302c20303230303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030300a0a4465636973696f6e733a0a2a20416c6c6f636174652024313020746f204a616d20696e2043656e7472616c205061726b2050617274790a2a20416c6c204d656d62657273204d75737420436f6e7472696275746520243520746f2047726f7570204b6974747920627920392f32342f32350a\" | xxd -r -p\n\nDate: 9/17/25\nPresent: 0100000000000000000000000000000000000000000000000000000000000000, 0200000000000000000000000000000000000000000000000000000000000000\n\nDecisions:\n* Allocate $10 to Jam in Central Park Party\n* All Members Must Contribute $5 to Group Kitty by 9/24/25\n</code></pre> <p>Sure enough, that's the original message. Once each of the participating signers has verified the message, they can sign.</p>"},{"location":"02_3_Creating_FROST_Signature/#finalizing-the-signature","title":"Finalizing the Signature","text":"<p>When the participants agree to sign (which just requires their agreements in the <code>participant</code> program), they send their signing shares to the <code>coordinator</code>. When the <code>coordinator</code> has received enough, it will aggregate a signature for the message file:</p> <pre><code>Waiting for participants to send their SignatureShares...\nReceived: {\"SignatureShare\":{\"header\":{\"version\":0,\"ciphersuite\":\"FROST-ED25519-SHA512-v1\"},\"share\":\"6682858a180be6f0527a6733d33c5c957a9c2e6ff91345bfbf15f53ff4d8d608\"}}\nReceived: {\"SignatureShare\":{\"header\":{\"version\":0,\"ciphersuite\":\"FROST-ED25519-SHA512-v1\"},\"share\":\"fb5f07e9722cebf1c517a4c5263937a1998056f4ad79bf373825667571938107\"}}\nClient disconnected\nClient disconnected\nRaw signature written to board-meeting-250917.sig\n</code></pre>"},{"location":"02_3_Creating_FROST_Signature/#ensuring-the-division","title":"Ensuring the Division","text":"<p>Though the above examples demonstrate signing occurring on a single host, the signing shares that make up a threshold should actually be divided, with multiple users holding them on multiple hosts. One of the major points of using FROST (but generally, of using any multisignature or threshold signature algorithm) is to protect your authorization by dividing it up.</p> <p>In this example, the two group members could be signing on different machines, which means that their actual key is never rquired to exist in a single place!</p> <p>By dividing authorization in this way, you ensure there is no Single Point of Failure (SPOF), which could lead to the loss of the authorization, and no Single Point of Compromise (SPOC), which could lead to the theft of the authorization.</p>"},{"location":"02_3_Creating_FROST_Signature/#summary-creating-a-frost-signature","title":"Summary: Creating a FROST Signature","text":"<p>Creating a FROST signature is a simple application of the protocol described in \u00a71.2: The FROST Signature Process. A coordinator organizes things; each participant sends commitments; the coordinator resends the commitments and the material to be signed; the participants use their signing shares; and the coordinator aggregates them to create the final signature.</p>"},{"location":"02_3_Creating_FROST_Signature/#whats-next","title":"What's Next","text":"<p>For the next step after \"Signing with FROST\", see \u00a72.4: Checking a FROST Signature.</p>"},{"location":"02_4_Checking_FROST_Signature/","title":"2.4: Checking FROST Signatures","text":"<p>If you receive a FROST signature, obviously you must be able to check it!</p> <p>:book: What is Required to Verify a Signature? Verification of a signature can typically be accomplished with three items: the message, the signature, and the public key (which is typically called the \"verifying key\" in relation to FROST).</p> <p>Following are some methodologies for verifying the ed25519 signature you created in \u00a72,3.</p> <p>:warning: WARNING: There are some issues with the canonicity of some edge-case ed25519 signatures as described here. ZF FROST and the verification tools described here seem to be in alignment. ZIP-215 seeks to resolve these issues and hopefully will be a touchstone for future ed25519 libraries.</p>"},{"location":"02_4_Checking_FROST_Signature/#verifying-on-the-command-line","title":"Verifying on the Command Line","text":"<p>Blockchain Commons has written <code>frost-verify</code>, a Rust tool designed to verify <code>ed25519</code> and <code>secp256k1-tr</code> FROST signatures.</p> <p>You can download and install <code>frost-verify</code> as follows:</p> <pre><code>git clone https://github.com/BlockchainCommons/frost-verify-rust.git\ncd frost-verify-rust\ncargo install --path .\n</code></pre> <p>Verifying a signature require three elements: the message that was signed; the public (verifying) key; and the signature. The trickiest thing is often knowing what format is expected for each of these files. Here's what you need when you use <code>frost-verify</code>:</p> <ul> <li>Message: The original (txt) message.</li> <li>Verifying Key: The <code>public-key-package.json</code> file generated by the ZF FROST Tools</li> <li>Signature: A binary version of the signature, which is the format generated by the ZF FROST Tool.</li> </ul> <p>With those in hand, you can use the <code>frost-verify</code> tool to verify your signature. The following flags can be used with <code>frost-verify verify</code>:</p> Flag Description Default Options -c Ciphersuite ed25519 redpallas -C Credentials -m Message -P Public Key Filename public-key-package.json -q Quiet Mode -s Signature Input File <p>Here's how to verify the <code>ed25519</code> signature you created in \u00a72.3: Creating a FROST Signature.</p> <pre><code>% frost-verify verify -m board-meeting-250917.txt -s board-meeting-250917.sig -P public-key-package.json\n\u2705 Signature verification: PASSED\n</code></pre> <p>If the test were not successful, you would instead see:</p> <pre><code>\u274c Signature verification: FAILED\n</code></pre> <p>:book: Is It Verify or Validate? RFC 4949 suggests that validate should refer to correctness and verify should refer to truth. These are also the most common definitions in the cryptographic world, so you verify a signature to see that it's authentic, though you might validate that it's the right format, the right length, etc.</p>"},{"location":"02_4_Checking_FROST_Signature/#creating-a-signature-for-testing","title":"Creating a Signature for Testing","text":"<p>The <code>frost-verify</code> program also allows for the creation of a test signature. All you need is the file to sign and <code>frost-verify test-sign</code> will create the signing shares, sign, and record the verifying key. The same flags are used as with the <code>frost-verify verify</code> command:</p> <pre><code> % frost-verify test-sign -m board-meeting-250917.txt -s board-meeting-250917.sig\n\u2705 Test signature and public key package generated:\n  Signature: board-meeting-250917.sig\n  Public key package: public-key-package.json\n</code></pre> <p>Afterward, you can verify as usual:</p> <pre><code>% frost-verify verify -m board-meeting-250917.txt -s board-meeting-250917.sig -P public-key-package.json\n</code></pre> <p>This is primarily useful for testing that the tool is working if you're having troubles verifying signatures that you made via other means.</p>"},{"location":"02_4_Checking_FROST_Signature/#verifying-on-the-web","title":"Verifying on the Web","text":"<p>The website cyphr.me offers a more general method for verifying ed25519 signatures, such as the one you created in this chapter.</p> <p></p> <p>To use it:</p> <ul> <li>Choose the Algorithm as \"ed25519\"</li> <li>Choose Message Encoding as \"hex\"</li> <li>Paste the hex-encoded version of <code>board-meeting-250917.txt</code> (or any other message converted to hex) as \"Message\", e.g.: <code>446174653a20392f31372f32350a50726573656e743a20303130303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030302c20303230303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030300a0a4465636973696f6e733a0a2a20416c6c6f636174652024313020746f204a616d20696e2043656e7472616c205061726b2050617274790a2a20416c6c204d656d62657273204d75737420436f6e7472696275746520243520746f2047726f7570204b6974747920627920392f32342f32350a</code></li> <li>Choose \"Key Encoding\" as \"hex\"</li> <li>Leave \"Seed\" blank.</li> <li>Paste the <code>verifying_key</code> from <code>public-key-package.json</code> as the \"Public Key\", e.g. <code>8f9ee5e7f2642ed8b7c4eb1c7342ecbf69e7284b07e18434e577ad580a1412ed</code>.</li> <li>Convert the binary signature in <code>board-meeting-250917.sig</code> (or any other signature file) to hex with <code>xxd -p -c0 board-meeting-250917.sig</code>, then paste that into \"Signature\", e.g.: <code>d558109f63f5042187daa81475895969bcc8afc48e0dca7dce31154087a65cd1740e971671d4be8a42f513561b7cb421141d8563a78d04f7f73a5bb5656c5800</code>.</li> <li>Click \"Verify\".</li> <li>You should see \"Valid Signature\".</li> </ul>"},{"location":"02_4_Checking_FROST_Signature/#verifying-with-code","title":"Verifying with Code","text":"<p>The ZF FROST Book notes that if you use the ZF FROST crates, you can simply verify a signature with the following code:</p> <pre><code>let is_signature_valid = pubkey_package\n    .verifying_key()\n    .verify(message, &amp;group_signature)\n    .is_ok();\n</code></pre> <p>The ed25519_zebra crate offers a similar solution:</p> <pre><code>assert!(\n    VerificationKey::try_from(vk_bytes)\n        .and_then(|vk| vk.verify(&amp;sig_bytes.into(), msg))\n        .is_ok()\n);\n</code></pre> <p>Either code base could be used to quickly develop a verification tool of your own.</p>"},{"location":"02_4_Checking_FROST_Signature/#summary-checking-frost-signatures","title":"Summary: Checking FROST Signatures","text":"<p>You've now experienced the basics of FROST hands-on. You created a FROST group in \u00a72.2, created a FROST signature in \u00a72.3, and verified a FROST signature here.</p> <p>You should have a good understanding of:</p> <ul> <li>What an m-of-n FROST group is.</li> <li>How signatures are created in two rounds, with commitments, then signatures, followed by aggregation.</li> <li>How you can use a message, signature, and verifying (public) key to verify a signature.</li> </ul> <p>That's the basics!</p>"},{"location":"02_4_Checking_FROST_Signature/#whats-next","title":"What's Next","text":"<p>Chapter 3: Advanced FROST Capabilities talks about some advanced features of FROST, some of which are fully supported by the modern CLI, some of which are not.</p>"},{"location":"03_0_Advanced_FROST/","title":"Chapter Three: Advanced FROST Capabilities","text":"<p>Among the more advanced capabilities of FROST are the ability to create shares using Distributed Key Generation (DKG) and the possibility to repair, refresh, and otherwise change shares after the fact.</p> <p>This chapter overviews these topics, though the latter is not yet available for hands-on experimentation in the CLI.</p>"},{"location":"03_0_Advanced_FROST/#objectives-for-this-chapter","title":"Objectives for this Chapter","text":"<p>After working through this chapter, a reader will be able to:</p> <ul> <li>Create DKG FROST Secret Shares</li> <li>Design User-Friendly DKG Interfaces</li> </ul> <p>Supporting objectives include the ability to:</p> <ul> <li>Understand the Difference Between DKG and TDG</li> <li>Understand How FROST Shares Can Be Modified</li> <li>Understand the Security Ramification of FROST Reshares</li> </ul>"},{"location":"03_0_Advanced_FROST/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Section One: Creating FROST Secret Shares with DKG Using CLI</li> <li>Section Two: Creating FROST Secret Shares with DKG Using Server</li> <li>Section Three: ZF FROST in a Nutshell</li> <li>Section Four: Resharing FROST Shares</li> </ul>"},{"location":"03_1_Creating_FROST_Secret_Shares_with_DKG_Using_CLI/","title":"3.1: Creating FROST Secret Shares with DKG Using CLI","text":"<p>\u00a72.2: Creating FROST Secret Shares with TDG overviewed the simplest way to create FROST shares, using Trusted Dealer Generation. However, the full power of FROST comes with the use of Distributed Key Generation (DKG). With this methodology, the combined signing key never exists in a single place: not when you're creating the signing shares, and not when you're using them.</p>"},{"location":"03_1_Creating_FROST_Secret_Shares_with_DKG_Using_CLI/#creating-dkg-shares-the-hard-way","title":"Creating DKG Shares the Hard Way","text":"<p>Creating secret shares with a Trusted Dealer is relatively simple: a single server creates a secret, it shards it, and it sends those shares out to the participants.</p> <p>Creating secret shares with Distributed Key Generation is more difficult because you have to engage in the two-round ceremony described in \u00a71.2: The FROST Signature Process, first broadcasting commitments to all participants, then sending to each individually. Each member needs to both send and receive \"n\" messages (1 broadcast message and \"n-1\" individual messages), where \"n\" is the number of participants. This can be very logistically tiresome and prone to error if a user has to do it all themself.</p> <p>:book: What is DKG? In Distributed Key Generation, multiple servers work together. At the end of the ceremony, each server will hold its own secret share without the original secret having been instantiated at any point.</p> <p>:book: Why is DKG Better than TDG? DKG is considerably more secure than TDG. With Trusted Dealer Generation, you have to trust the trusted dealer (hence the name!). You have to trust not just that they're not going to steal your secret, but also that they're secure (so that someone else can't steal the secret), that their network is secure, and that they will properly (and securely!) delete the secret after it's sharded and distributed. None of this trust is required for DKG! Because the secret never exists in one place, the only way to compromise it is to steal multiple shares (assuming the threshold is larger than 1), and that should be difficult because the shares should be securely stored on multiple sites.</p> <p>:book: How Do the ZF FROST Tools Support DKG? ZF FROST offers two methods for generating DKG shares. One uses the <code>dkg</code> CLI to generate shares, but requires the participants to do the exchange of commitments themselves. The other uses the <code>server</code> app, which takes some effort to setup, but which takes the logistical burden from the user. The CLI method is described in this section, the server-based functionality in the next section..</p> <p>This section demonstrates how to create DKG shares using the <code>dkg</code> CLI that you already installed as part of the ZF FROST <code>frost-client</code> package. It requires you to take care of all of the logistical exchange of information.</p> <p>To start with, each participant will run <code>dkg</code> from the command line of their own machine, entering in the threshold and signing number (which must match across all participants) and their own identifer (which must be unique for each participant:</p> <pre><code>% dkg\nThe minimum number of signers: (2 or more)\n2\nThe maximum number of signers:\n3\nYour identifier (this should be an integer between 1 and 65535):\n1\n</code></pre> <p>This example demonstrates Alice's console, but Bob is doing the same (with identifier <code>2</code>) as is Eve (with identifier <code>3</code>).</p> <p>Each user will then be given a hex string version of their identifier and a broadcast commitment that they must send to all the other participants.</p> <p>Here's what that looks like for Alice:</p> <pre><code>=== ROUND 1: SEND PACKAGES ===\n\nRound 1 Package to send to all other participants (your identifier: \"0100000000000000000000000000000000000000000000000000000000000000\"):\n\n{\"header\":{\"version\":0,\"ciphersuite\":\"FROST-ED25519-SHA512-v1\"},\"commitment\":[\"f6b7158d8140d5503a2a4c46d6d3e7bfb52f132362a1464156ae553b0846fe7d\",\"6e929c2076cb52266ff05e5406512881d098ff5666a85fc51487842be05076d5\"],\"proof_of_knowledge\":\"0624a9059dda9eb17a0ddad6a035eba27e951512495efb155f9fc4d9fddbcdf077ece4768ae32cecc6df9f98461a0d6a7f6a6a0ac26eb76ce814fe5dc820a70d\"}\n</code></pre> <p>Alice should send her packets out, but she should also receive packages from Bob and Eve. For each package that she receives, she enters the identifier of the sender as well as the package into her own <code>dkg</code> console:</p> <pre><code>=== ROUND 1: RECEIVE PACKAGES ===\n\nInput Round 1 Packages from the other 2 participants.\n\nThe sender's identifier (hex string):\n0200000000000000000000000000000000000000000000000000000000000000\nTheir JSON-encoded Round 1 Package:\n{\"header\":{\"version\":0,\"ciphersuite\":\"FROST-ED25519-SHA512-v1\"},\"commitment\":[\"272617337510d27c1d82792c2168b002770eb14fe3dd807a2571ce40099c3e14\",\"09e8de0f722ff2b61be60ba6858e4c673386a23669b9f88c611dd3a8478a1f9e\"],\"proof_of_knowledge\":\"793f45332587cbd8419fd0e72e5ecf45084aef3bdb4d868355bb106d1b7224f7e399869a99f66fdb1a7c53b30c3870c9a64b340ec35cffaba22879835a994507\"}\n\nThe sender's identifier (hex string):\n0300000000000000000000000000000000000000000000000000000000000000\nTheir JSON-encoded Round 1 Package:\n{\"header\":{\"version\":0,\"ciphersuite\":\"FROST-ED25519-SHA512-v1\"},\"commitment\":[\"95817e076aeb2c4de3d506719da927c2cc99bd793f32d4bdf18795468b7e296b\",\"679b7ae4066cceba11c790e1493e15614ea4eabe54ab0ae4ba6b6f14d7668d2a\"],\"proof_of_knowledge\":\"d0313c8ced787cfecccfba375a4b8a7142d82ec7102dbbd842e7443e647c290113422400464e363c5dfb9097a54919978714634341d50909e83a51954bac5c0d\"}\n</code></pre> <p>When a participant has entered all of the packages from the other participants, they'll be shown their round 2 packets, which must be sent individually and securely to each participant:</p> <pre><code>=== ROUND 2: SEND PACKAGES ===\n\nRound 2 Package to send to participant \"0200000000000000000000000000000000000000000000000000000000000000\" (your identifier: \"0100000000000000000000000000000000000000000000000000000000000000\"):\n\n{\"header\":{\"version\":0,\"ciphersuite\":\"FROST-ED25519-SHA512-v1\"},\"signing_share\":\"36c4a4c744d69fba78516fb6cddf03d618ef77ac0a97de1e343d67b9f7eda00a\"}\n\nRound 2 Package to send to participant \"0300000000000000000000000000000000000000000000000000000000000000\" (your identifier: \"0100000000000000000000000000000000000000000000000000000000000000\"):\n\n{\"header\":{\"version\":0,\"ciphersuite\":\"FROST-ED25519-SHA512-v1\"},\"signing_share\":\"62746f98a7626ffed4bf767ad971c655529ac6410b2e312970c7de8931b99c0d\"}\n</code></pre> <p>They also will receive packages from each participant, which they must again enter alongside the identifier for the other participant:</p> <pre><code>=== ROUND 2: RECEIVE PACKAGES ===\n\nInput Round 2 Packages from the other 2 participants.\n\nThe sender's identifier (hex string):\n0200000000000000000000000000000000000000000000000000000000000000\nTheir JSON-encoded Round 2 Package:\n{\"header\":{\"version\":0,\"ciphersuite\":\"FROST-ED25519-SHA512-v1\"},\"signing_share\":\"3c18c0d51bffe439728569b2f3f2906a669458197ec0cbe1dc609b42e56d740b\"}\n\nThe sender's identifier (hex string):\n0300000000000000000000000000000000000000000000000000000000000000\nTheir JSON-encoded Round 2 Package:\n{\"header\":{\"version\":0,\"ciphersuite\":\"FROST-ED25519-SHA512-v1\"},\"signing_share\":\"eca669a661c61dacf0a4b148eb37bfc02ca939b7905ea90513eeec30abd48700\"}\n</code></pre> <p>As soon as a participant has entered all of the packages from the other users (and even before those other users necessarily finish the process), they'll be given their share of the signing key as well as the public key package:</p> <pre><code>=== DKG FINISHED ===\nParticipant key package:\n\n{\"header\":{\"version\":0,\"ciphersuite\":\"FROST-ED25519-SHA512-v1\"},\"identifier\":\"0100000000000000000000000000000000000000000000000000000000000000\",\"signing_share\":\"45ff0d1645acc004a9708b4ac27eb26c7281bbe7181f01fce701785c4e65a103\",\"verifying_share\":\"32bb144163d32dd166ab7534ee53a01fc6eac5dba9f2057ed2b38a842762cb9f\",\"verifying_key\":\"67b2d1d24ed2f2cb78ffefe6699c4114e479f95621d5ab2720687dcf593bdcfe\",\"min_signers\":2}\n\nParticipant public key package:\n\n{\"header\":{\"version\":0,\"ciphersuite\":\"FROST-ED25519-SHA512-v1\"},\"verifying_shares\":{\"0100000000000000000000000000000000000000000000000000000000000000\":\"32bb144163d32dd166ab7534ee53a01fc6eac5dba9f2057ed2b38a842762cb9f\",\"0200000000000000000000000000000000000000000000000000000000000000\":\"1ae2f34429c0cf7b7757c2f537eada432e8573f06f7258f9510a013ff926159f\",\"0300000000000000000000000000000000000000000000000000000000000000\":\"5276b15b25f29f7dd42e47cf5272f320e8a4d5ed9f27943d240dc29259c22985\"},\"verifying_key\":\"67b2d1d24ed2f2cb78ffefe6699c4114e479f95621d5ab2720687dcf593bdcfe\"}\n</code></pre> <p>This information must be saved to files. The \"Participant key package\" contains the secret info and should be protected accordingly. In these examples it's stored as <code>key-package-#.json</code>. The \"Participant public key package\" is the public info, including the verifying key, which doesn't need to be secured. It should be stored as <code>public-key-package.json</code>.</p> <p>Whew!</p> <p>You can follow along with this tutorial simply by running <code>dkg</code> in three different windows (even on the same machine, though that wouldn't be the case in a real-world deployment) and exchanging information among them. It's a great hands-on example of how the exchange detailed in \u00a71.2 works, but it also demonstrates how cumbersome the exchanges are for a user, especially as the number of partipants increase. If you make a single mistake, entering in the wrong participant or the wrong package at any point, the entire process will fail, and you'll only know at the end!</p> <p>That's why engineers need to design better processes that automate the exchanges of the two rounds, which is exactly what happens when using ZF FROST's server-based method of DKG creation, in \u00a73.2.</p>"},{"location":"03_1_Creating_FROST_Secret_Shares_with_DKG_Using_CLI/#signing-with-dkg-shares","title":"Signing with DKG Shares","text":"<p>If you saved all the data to files and named them appropriately, you can now sign with your DKG shares using the same process you used for signing with the TDG shares in \u00a72.3: Creating a FROST Signature.</p> <p>On the server:</p> <pre><code>% coordinator -m board-meeting-250917.txt -s board-meeting-250917.sig -n 2\n</code></pre> <p>On Alice's machine:</p> <pre><code>% participant -k key-package-1.json\n</code></pre> <p>On Bob's machine:</p> <pre><code>% participant -k key-package-2.json\n</code></pre> <p>The result should be just as before. Here's what the <code>coordinator</code>'s console shows:</p> <pre><code>Received: {\"IdentifiedCommitments\":{\"identifier\":\"0100000000000000000000000000000000000000000000000000000000000000\",\"commitments\":{\"header\":{\"version\":0,\"ciphersuite\":\"FROST-ED25519-SHA512-v1\"},\"hiding\":\"a2e21b5a1963c011e2a1d9229ebcfccfc55d38f65347de2aa24852d154565476\",\"binding\":\"f0258062753269bbecac60c49b4b6e7ed1c13b567ce603cc2919375c611e7055\"}}}\nReceived: {\"IdentifiedCommitments\":{\"identifier\":\"0200000000000000000000000000000000000000000000000000000000000000\",\"commitments\":{\"header\":{\"version\":0,\"ciphersuite\":\"FROST-ED25519-SHA512-v1\"},\"hiding\":\"db16d12c421c6779ed2bf059a4f15794b86d35f70a549b02981817602b55ffe5\",\"binding\":\"90b477e71ab324183286d57397b19988d5aa186f61a70fbe088b9a3e62796544\"}}}\nSending SigningPackage to participants...\nWaiting for participants to send their SignatureShares...\nReceived: {\"SignatureShare\":{\"header\":{\"version\":0,\"ciphersuite\":\"FROST-ED25519-SHA512-v1\"},\"share\":\"7769b727b2d2cb4b34ea9c89fb05a14448ff925603fbd4dd34e76fea043ddf06\"}}\nClient disconnected\nReceived: {\"SignatureShare\":{\"header\":{\"version\":0,\"ciphersuite\":\"FROST-ED25519-SHA512-v1\"},\"share\":\"01460dba3c43ae9e481523568a95ac7cd6a2c2676ef23c673d3ce7b11574d00a\"}}\nRaw signature written to board-meeting-250917.sig\n</code></pre>"},{"location":"03_1_Creating_FROST_Secret_Shares_with_DKG_Using_CLI/#verifying-with-dkg-shares","title":"Verifying with DKG Shares","text":"<p>Because the files created by <code>dkg</code> are just like those created with <code>trusted-dealer</code>, you can verify in exactly the same way, as described in \u00a72.4.</p>"},{"location":"03_1_Creating_FROST_Secret_Shares_with_DKG_Using_CLI/#summary-creating-frost-secret-shares-with-dkg-using-cli","title":"Summary: Creating FROST Secret Shares with DKG Using CLI","text":"<p>Creating shares with Distributed Key Generation (DKG) can take some work because it's a two-round process where each of <code>n</code> participants need to send <code>n</code> messages, resulting in <code>n^2</code> total communications. That's somewhat unwieldly for three participants and totally unmanageable for many more. Nonethless, walking through it once is a great example of the how the DKG process works.</p>"},{"location":"03_1_Creating_FROST_Secret_Shares_with_DKG_Using_CLI/#whats-next","title":"What's Next","text":"<p>For a more user-friendly example of DKG, see \u00a73.2: Creating FROST Secret Shares with DKG Using Server.</p>"},{"location":"03_2_Creating_FROST_Secret_Shares_with_DKG_Using_Server/","title":"3.2: Creating FROST Secret Shares with DKG Using Server","text":"<p>The ZF FROST tools offers two ways to create DKG shares. The first way, demoed in \u00a73.1 forces users to hand-input all the communications being exchanged, which is a pragmatic UI (and a nice bit of hands-on experience to show you how it all works), but is prone to error.</p> <p>Fortunately, the ZF FROST tools have a better answer: a server-based methodology.</p>"},{"location":"03_2_Creating_FROST_Secret_Shares_with_DKG_Using_Server/#preparing-the-server","title":"Preparing the Server","text":"<p>This DKG demo manages communication through a server, <code>frostd</code>, which must also have a certificate. Communication connections are authenticated, and communication is encrypted, providing a level of security that's appropriate for the use of the higher security profile of DKG. But the most important element may be the improved UI: the server takes care of things so that the user doesn't have to, largely elminating the opportunity for errors.</p>"},{"location":"03_2_Creating_FROST_Secret_Shares_with_DKG_Using_Server/#installing-the-server","title":"Installing the Server","text":"<p><code>frostd</code> is the other major software available in the <code>frost-tools</code> repo. You can install it by changing back to the <code>frost-tools</code> directory that you cloned from GitHub and running <code>cargo install</code> for <code>frostd</code>:</p> <pre><code>% cargo install --path frostd\n</code></pre> <p>:information_source: NOTE: If you no longer have your <code>frost-tools</code> repo (or have lost track of it), refer to \u00a72.1: Installing the FROST Tools for the installation instructions.</p>"},{"location":"03_2_Creating_FROST_Secret_Shares_with_DKG_Using_Server/#installing-a-certificate","title":"Installing a Certificate","text":"<p>The <code>mkcert</code> app allows you to create test certificates on your machine. Look at the README in that repo for full installation instructions, but most simply you can: <code>brew install mkcert</code> (Mac); <code>sudo apt install libnss3-tools</code> (Linux); or <code>choco install mkcert</code> (Windows). If you use a different package manager, there are probably instructions on what to do at the <code>mkcert</code> repo.</p> <p>After installing the <code>mkcert</code> software, you can create a testing certificate for your <code>localhost</code> machine with the following commands:</p> <pre><code>% mkcert -install\n</code></pre> <p>On a Mac, this will require you to enter your password for <code>sudo</code> and to update your system settings. Other systems will require slightly different verifications.</p> <p>You may also get some status reports including some errors like this, which are fine because you're not creating this certificate for Firefox:</p> <pre><code>Warning: \"certutil\" is not available, so the CA can't be automatically installed in Firefox! \u26a0\ufe0f\n</code></pre> <p>You can now create a certificate for your local machine:</p> <pre><code>% mkcert localhost 0.0.0.0 127.0.0.1 ::1\n\nCreated a new certificate valid for the following names \ud83d\udcdc\n - \"localhost\"\n - \"0.0.0.0\"\n - \"127.0.0.1\"\n - \"::1\"\n</code></pre> <p>You'll also be told where your certificates are, which should be something like::</p> <pre><code>The certificate is at \"./localhost+3.pem\" and the key at \"./localhost+3-key.pem\" \u2705\n</code></pre> <p>(The precise filename will vary if you create for a different machine name and/or with a different number of aliases.)</p>"},{"location":"03_2_Creating_FROST_Secret_Shares_with_DKG_Using_Server/#starting-the-server","title":"Starting the Server","text":"<p>You can now start the <code>frostd</code> server with that certificate:</p> <pre><code>% frostd  --tls-cert localhost+3.pem --tls-key localhost+3-key.pem\n</code></pre> <p>It will run in the foreground and report out messages to you:</p> <pre><code>2025-09-19T00:55:10.092611Z  INFO frostd: server running\n2025-09-19T00:55:10.093142Z  INFO frostd: starting HTTPS server at 0.0.0.0:2744\n</code></pre>"},{"location":"03_2_Creating_FROST_Secret_Shares_with_DKG_Using_Server/#preparing-the-users","title":"Preparing the Users","text":"<p>Now, the users need to be able to talk to each other securely via that server.</p>"},{"location":"03_2_Creating_FROST_Secret_Shares_with_DKG_Using_Server/#create-user-credentials","title":"Create User Credentials","text":"<p>To communicate sercurely, each user will need to create credentials, which can be done with the <code>frost-client</code> utility:</p> <pre><code>% frost-client init -c alice.toml\n% frost-client init -c bob.toml\n% frost-client init -c eve.toml\n</code></pre> <p>Usually, each user would do this on their own machine, but again for simplicity we're doing everything on a single machine.</p> <p>Here's what the <code>alice.toml</code> configuration files looks like:</p> <pre><code>version = 0\n\n[communication_key]\nprivkey = \"04692aef6190b43d9524d719e0a7f45689ea3265a36fe34e69c625a9b8ac2967\"\npubkey = \"00d639b42342ec83031c0cfb0462cb759832fb4d7b7c5942edd3c067b465406f\"\n\n[contact]\n\n[group]\n</code></pre> <p>It contains a communication key, which is the last crucial element of the client-server setup, because it allows the members who will form the FROST group to authenticate each other and to encrypt communications, using the keypair.</p>"},{"location":"03_2_Creating_FROST_Secret_Shares_with_DKG_Using_Server/#installing-tomlq","title":"Installing tomlq","text":"<p>In order to easily read those config files from the command line, you'll need a tool called <code>tq</code>, which is a Rust Tool that can be installed from the tomlq repo.</p> <pre><code>% git clone https://github.com/cryptaliagy/tomlq.git\n%  cd tomlq\n%  cargo install --path .\n</code></pre>"},{"location":"03_2_Creating_FROST_Secret_Shares_with_DKG_Using_Server/#extracting-the-contact-info","title":"Extracting the Contact Info","text":"<p>Now you can use those TOML files, <code>tq</code>, and the <code>frost-client</code> to record the public key and the ZF FROST contact string for each user:</p> <pre><code>ALICE_PUBKEY=$(tq -f alice.toml -r 'communication_key.pubkey')\nALICE_CONTACT=$(frost-client export --name \"Alice\" -c alice.toml 2&gt;&amp;1 | tail -1)\nBOB_PUBKEY=$(tq -f bob.toml -r 'communication_key.pubkey')\nBOB_CONTACT=$(frost-client export --name \"Bob\" -c bob.toml 2&gt;&amp;1 | tail -1)\nEVE_PUBKEY=$(tq -f eve.toml -r 'communication_key.pubkey') \nEVE_CONTACT=$(frost-client export --name \"Eve\" -c eve.toml 2&gt;&amp;1 | tail -1)\n</code></pre> <p>The <code>PUBKEY</code> just contains the public key in the TOML file, while the contact string encodes that to allow it to be passed to another <code>frost-client</code>. Here's what they look like.</p> <pre><code>% echo $ALICE_PUBKEY\n00d639b42342ec83031c0cfb0462cb759832fb4d7b7c5942edd3c067b465406f\n% echo $ALICE_CONTACT\nzffrost1qyqq2stvd93k2gqq6cumgg6zajpsx8qvlvzx9jm4nqe0kntm03v59mwncpnmge2qdu8ya0ws\n</code></pre>"},{"location":"03_2_Creating_FROST_Secret_Shares_with_DKG_Using_Server/#exchanging-the-contact-information","title":"Exchanging the Contact Information","text":"<p>At this point, in the real world, each user would have collected their own <code>PUBKEY</code> and <code>CONTACT</code>. Now, they would need to send these two long strings of data to each of the other users who will be participating in the FROST group. They could send it over a secure messaging system such as Signal, but it'd be better to meet in person so that you can verify that the information belongs to a known person.</p> <p>(In this example, we're simply assuming the strings we've stored in variables have gotten to the other users.)</p>"},{"location":"03_2_Creating_FROST_Secret_Shares_with_DKG_Using_Server/#importing-the-contact-information","title":"Importing the Contact Information","text":"<p>The <code>frost-client</code> will directly digest the contact info.</p> <p>Each user needs to collect the information from each of the other users. So Alice would <code>import</code> the following into her <code>toml</code> file.:</p> <pre><code>frost-client import -c alice.toml $BOB_CONTACT\nfrost-client import -c alice.toml $EVE_CONTACT\n</code></pre> <p>These commands will show the following results:</p> <pre><code>Imported this contact:\nName: Bob\nPublic Key: 2f232f8a6f69d7dac39cbadff58fc753066bed7ec7d2401acb838e1b033c2305\n</code></pre> <p>And:</p> <pre><code>Imported this contact:\nName: Eve\nPublic Key: f2f2f9344e203c1279e6997d8f9030d7727d36a2ba053a1ec3b1f3dae266a26d\n</code></pre> <p>Afterward, <code>alice.toml</code> should be updated accordingly:</p> <pre><code>version = 0\n\n[communication_key]\nprivkey = \"04692aef6190b43d9524d719e0a7f45689ea3265a36fe34e69c625a9b8ac2967\"\npubkey = \"00d639b42342ec83031c0cfb0462cb759832fb4d7b7c5942edd3c067b465406f\"\n\n[contact.Bob]\nname = \"Bob\"\npubkey = \"2f232f8a6f69d7dac39cbadff58fc753066bed7ec7d2401acb838e1b033c2305\"\n\n[contact.Eve]\nname = \"Eve\"\npubkey = \"f2f2f9344e203c1279e6997d8f9030d7727d36a2ba053a1ec3b1f3dae266a26d\"\n\n[group]\n</code></pre> <p>As shown, the ZF FROST contact info has been converted back to a public key. As long as Alice trusted the method of distribution for the contact info (and the source of that information) they now will be able to trust information from Bob or from Eve that is signed with the corresponding private key.</p> <p>Bob does the same:</p> <pre><code>frost-client import -c bob.toml $ALICE_CONTACT\nfrost-client import -c bob.toml $EVE_CONTACT\n</code></pre> <p>As does Eve:</p> <pre><code>frost-client import -c eve.toml $ALICE_CONTACT\nfrost-client import -c eve.toml $BOB_CONTACT\n</code></pre> <p>Besides importing the <code>CONTACT</code> into their <code>toml</code> file, each user would also set a <code>PUBKEY</code> variable for each other user, as doing so will make it easier to contact the server, momentarily.</p> <p>And now we've got a server and enough information to get started creating the DKG!</p>"},{"location":"03_2_Creating_FROST_Secret_Shares_with_DKG_Using_Server/#creating-dkg-shares","title":"Creating DKG Shares","text":"<p>You're now ready to create shares using ZF FROST's server-based DKG method.</p> <p>You should already have <code>frostd</code> running. Each user will now run <code>frost-client</code> on their own terminal to connect to that server. The following command-line options are used when running <code>frost-client</code></p> Flag Description Default Options -d Description -s Server URL -S Public Keys -t Threshold -C Cipher Suite ed25519 -c TOML File"},{"location":"03_2_Creating_FROST_Secret_Shares_with_DKG_Using_Server/#connecting-to-the-server","title":"Connecting to the Server","text":"<p>The following commands will initiate the DKG Protocol. They should be used by the first user to connect.</p> <p>Alice runs:</p> <pre><code>% frost-client dkg -d \"DKG: Alice, Bob, Eve\" \\\n-s 127.0.0.1:2744 \\\n-S $BOB_PUBKEY,$EVE_PUBKEY \\\n-t 2 \\\n-c alice.toml\n</code></pre> <p>Note that:</p> <ul> <li>The <code>-d</code> description is just a label put into the individual's TOML file.</li> <li>The <code>-s</code> server name and port number will have appeared when the server started, but it should usually be <code>127.0.0.1:2744</code>.</li> <li>The <code>-S</code> public keys are why we saved those keys in <code>$PUBKEY</code> variables, but you could just as easily have entered them by hand. The first user to initiate the <code>dkg</code> connection enters the keys of the other two. They won't need to do so at all (and in fact, doing so caused the DKG to fail in our tests, which clearly shouldn't be the case if all the keys match).</li> <li>The <code>-t</code> is the threshold, in this case 2 out of the three pubkeys (the user's own and the ones entered as <code>-S</code>). If the number of pubkeys and/or the threshold don't match, things won't work! Everyone will just wait around, because there aren't enough participants to create the requested DKG.</li> <li>The <code>-c</code> is the config file for each individual user. This one is Alice's.</li> </ul> <p>Bob's command will then look like this:</p> <pre><code>% frost-client dkg -d \"DKG: Alice, Bob, Eve\" \\\n-s 127.0.0.1:2744 \\\n-t 2 \\\n-c bob.toml\n</code></pre> <p>Eve's will look like this:</p> <pre><code>% frost-client dkg -d \"DKG: Alice, Bob, Eve\" \\\n-s 127.0.0.1:2744 \\\n-t 2 \\\n-c eve.toml\n</code></pre> <p>Note that both omit the <code>-S</code> flag; not doing so might cause the DKG to hang.</p> <p>Each user should see the following:</p> <pre><code>Logging in...\nCreating DKG session...\nGetting session info...\nWaiting for other participants to send their Round 1 Packages............\n</code></pre> <p>Things will pause here while everyone connects ... and could get stuck here if there's a problem such as a discrepency between thresholds or public keys. (This is also where things got stuck when we tried to use the <code>-S</code> flag for non-initiating users.)</p> <p>But hopefully, everyone soon sees the following:</p> <pre><code>Waiting for other participants to send their broadcasted Round 1 Packages.....\nWaiting for other participants to send their Round 2 Packages....\nGroup created; information written to alice.toml\n</code></pre> <p>That's right, it's all done automatically from the initial connection, as long as each user set up their initial comunication keys correctly!</p> <p>Here's a look at Alice's TOML after the process:</p> <pre><code>version = 0\n\n[communication_key]\nprivkey = \"cb3d54011ad8c05d714ff2bb3b0466917723624ba89fd28b8df7c0a1b56b2e1a\"\npubkey = \"492dd8fced4ec58490800ec6216ca3fff0ed7148fad20cd7a9da52e62d6ddf26\"\n\n[contact.Bob]\nname = \"Bob\"\npubkey = \"6ba29fa51f76f6de6e99ce98767e56e9716fddb39c27bdf48d8d5458e22c8f77\"\n\n[contact.Eve]\nname = \"Eve\"\npubkey = \"dcffe972745b7f9a9d44f422c4b60de3ffc18d913bbe22d17627f864ffd34f15\"\n\n[group.7de1487fe264ab9ae292fcbce0e5dc1bb5524c810beae7119de74c99aa313e6c]\ndescription = \"DKG: Alice, Bob, Eve\"\nciphersuite = \"FROST-ED25519-SHA512-v1\"\npublic_key_package = \"00b169f0da03577250dcbe4c4589fb88caa29634135be4a78b49f626d890a354cf4354859f050d69dc7af725101636926792b6ecc41a7e24dbe5ad92bc88e61619bfb433cb84b8a48843f96a8f5d9c0b19e24c8caea907a91b526c6a60da8797453d4b2c240df46c0a8e1dab98621d1dbbccb5f091b30cf469f77c035181b80580bb595a4ad382e52235a65875816d0fa17e771db3711a7c4c8afba36f5febcf1ef68e48af0fa46286abe1e5e1e8b4740752420da1eedf69b83a34e3b4f60bc7b8b1f9a02c757de1487fe264ab9ae292fcbce0e5dc1bb5524c810beae7119de74c99aa313e6c\"\nkey_package = \"00b169f0da577250dcbe4c4589fb88caa29634135be4a78b49f626d890a354cf4354859f05ddb0f4708376b99de06d4a086c6c6371d7992102201ec39e6426555fa46abe040d69dc7af725101636926792b6ecc41a7e24dbe5ad92bc88e61619bfb433cb847de1487fe264ab9ae292fcbce0e5dc1bb5524c810beae7119de74c99aa313e6c02\"\nserver_url = \"127.0.0.1:2744\"\n\n[group.7de1487fe264ab9ae292fcbce0e5dc1bb5524c810beae7119de74c99aa313e6c.participant.577250dcbe4c4589fb88caa29634135be4a78b49f626d890a354cf4354859f05]\nidentifier = \"577250dcbe4c4589fb88caa29634135be4a78b49f626d890a354cf4354859f05\"\npubkey = \"492dd8fced4ec58490800ec6216ca3fff0ed7148fad20cd7a9da52e62d6ddf26\"\n\n[group.7de1487fe264ab9ae292fcbce0e5dc1bb5524c810beae7119de74c99aa313e6c.participant.82e52235a65875816d0fa17e771db3711a7c4c8afba36f5febcf1ef68e48af0f]\nidentifier = \"82e52235a65875816d0fa17e771db3711a7c4c8afba36f5febcf1ef68e48af0f\"\npubkey = \"dcffe972745b7f9a9d44f422c4b60de3ffc18d913bbe22d17627f864ffd34f15\"\n\n[group.7de1487fe264ab9ae292fcbce0e5dc1bb5524c810beae7119de74c99aa313e6c.participant.b8a48843f96a8f5d9c0b19e24c8caea907a91b526c6a60da8797453d4b2c240d]\nidentifier = \"b8a48843f96a8f5d9c0b19e24c8caea907a91b526c6a60da8797453d4b2c240d\"\npubkey = \"6ba29fa51f76f6de6e99ce98767e56e9716fddb39c27bdf48d8d5458e22c8f77\"\n</code></pre> <p>It now contains the FROST group of Alice, Bob, and Eve, along with information on each participant.</p> <p>This is very much the sort of UI you want for DKG creation: automated.</p> <ol> <li>The users have private and public keys that are automatically generated.</li> <li>The DKG ceremony happens through a server that uses those keys to secure communication.</li> <li>All the user has to do is intiate a connection.</li> <li>Both rounds of communication happen in the background, then the DKG key shares are automatically stored.</li> </ol>"},{"location":"03_2_Creating_FROST_Secret_Shares_with_DKG_Using_Server/#signing-with-dkg-shares-generated-by-the-server","title":"Signing with DKG Shares Generated by the Server","text":"<p>In order to sign with your new DKG shares, you must still be running <code>frostd</code>, and then you must run <code>frost-client coordinator</code> to connect to the server and manage the signing session.</p> <p><code>frost-client coordinator</code> can be run with the following flags:</p> Flag Description Default Options -c Credentials credentials.toml -g Group ID &lt;#&gt; -m Message -o Signature Output File -r Randomizers -s Server URL -S Signers <p>:warning: WARNING: Note that <code>frost-client coordinator</code> is a different program from the <code>coordinator</code> that you previously ran. That was a standalone server, this is one that is run through <code>frostd</code>. As a result, some of the command-line options are different (and one even reuses the same argument for a different purpose, so be careful!).</p> <p>Everyone will need to know the Group ID of this FROST group to communicate. This appears throughout the credentials files in lines like this:</p> <pre><code>[group.f6b2f30a4f3a666110478eca120a9a7d19740390fff8bb2250eb274177e6dd22.participant.2cb07edbc49dbcac5aa169c6f0c417e3a170431db15265ffc90e9f161b87c108]\n</code></pre> <p>Alice can capture it as follows:</p> <pre><code>% GROUP_ID=$(grep -oE '^\\[group\\.[0-9a-f]+' alice.toml | head -1 | sed 's/^\\[group\\.//')\n</code></pre> <p>Alice can now start up the <code>coordinator</code> as follows.</p> <pre><code>frost-client coordinator --group $GROUP_ID -s 127.0.0.1:2744 -S \"$ALICE_PUBKEY,$BOB_PUBKEY\" -m board-meeting-250917.txt -o board-meeting-250917.sig -c alice.toml\n</code></pre> <p>She is supplying her credentials file, so that the <code>frost-client coordinator</code> can look up the group, and she is picking the two people who will sign: herself and Bob. Eve signing this transaction will not result in it being valid!</p> <p>Alice should see these results:</p> <pre><code>Reading message from board-meeting-250917.txt...\nLogging in...\nCreating signing session...\nWaiting for participants to send their commitments......\n</code></pre> <p>Now each of Alice and Bob need to run <code>frost-client participant</code> to do the actual signing. Yes, this does mean that Alice is running two programs, <code>frost-client coordinator</code> and the <code>frost-client participant</code>!</p> <p>This is a simple command that just requires the Group ID, the server URL, and the credentials file:</p> <pre><code>GROUP_ID=$(grep -oE '^\\[group\\.[0-9a-f]+' alice.toml | head -1 | sed 's/^\\[group\\.//')\nfrost-client participant -g $GROUP_ID -s 127.0.1:2744 -c alice.toml\n</code></pre> <p>Bob does the same:</p> <pre><code>GROUP_ID=$(grep -oE '^\\[group\\.[0-9a-f]+' bob.toml | head -1 | sed 's/^\\[group\\.//')\nfrost-client participant -g $GROUP_ID -s 127.0.0.1:2744 -c bob.toml\n</code></pre> <p>:warning: WARNING: Again <code>participant</code> and <code>frost-client participant</code> are different programs.</p> <p>They should each see:</p> <pre><code>Logging in...\nJoining signing session...\nSending commitments to coordinator...\nWaiting for coordinator to send signing package...........\nMessage to be signed (hex-encoded):\n446174653a20392f31372f32350a50726573656e743a20303130303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030302c20303230303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030300a0a4465636973696f6e733a0a2a20416c6c6f636174652024313020746f204a616d20696e2043656e7472616c205061726b2050617274790a2a20416c6c204d656d62657273204d75737420436f6e7472696275746520243520746f2047726f7570204b6974747920627920392f32342f32350a\nDo you want to sign it? (y/n)\n</code></pre> <p>Much as when signing after TDG, that hex-encoding should be checked so that you know what you're signing. That can be done with <code>echo \"&lt;hex&gt;\" | xxd -r -p</code>.</p> <p>After they sign, the participants should see:</p> <pre><code>Sending signature share to coordinator...\nDone\n</code></pre> <p>Then the coordinator should see:</p> <pre><code>Raw signature written to board-meeting-250917.sig\n</code></pre> <p>That's it. Due to the ease of use of the <code>frost-client</code> and <code>frostd</code>, the signing is done already!</p>"},{"location":"03_2_Creating_FROST_Secret_Shares_with_DKG_Using_Server/#verifying-with-dkg-shares-generated-by-the-server","title":"Verifying with DKG Shares Generated by the Server","text":"<p>You can use the <code>frost-verify</code> program that you downloaded in \u00a72.4 to check your new signature. You just need to account for the fact that your public key package is now stored in your credentials file (e.g., <code>alice.toml</code>) rather than a separate public key package file. To support this, you use the <code>-C</code> flag and list your credentials file rather than the <code>-P</code> flag that you used previously.</p> <pre><code>% frost-verify verify -m board-meeting-250917.txt -s board-meeting-250917.sig -C alice.toml\n\u2705 Signature verification: PASSED\n</code></pre>"},{"location":"03_2_Creating_FROST_Secret_Shares_with_DKG_Using_Server/#accessing-the-public-key-package-programmatically","title":"Accessing the Public Key Package Programmatically","text":"<p>If you look at your credentials file, you'll see that the <code>public_key_package</code> is recorded by the ZF FROST server in hex, not an easy-to-read JSON file, as was the case when you used the previous CLI tools:</p> <p><code>public_key_package = \"00b169f0da032cb07edbc49dbcac5aa169c6f0c417e3a170431db15265ffc90e9f161b87c10893b643f9c6aeb52b094407bc3be61faa261d304ec6db6337ad05811f4d6aa482aab71ca92218f843a1f673f1428737de78512df0efc9e1108e3a8624cd05b90c3415e1c341ad3ca3de173b4e274b2cb2551a3f2ffef8824892d8fabdfcf786f637087bae60ed73e128a3d6c383491e31403bddf40ef33b4531b2e1cb1a76310db7c3534af91f5e02880f8b38d8a11d77345d2219481292fc5a5ee03d8edd0a6bf6b2f30a4f3a666110478eca120a9a7d19740390fff8bb2250eb274177e6dd22\"</code> This is a hex encoding of a Rust vector. If you decide that you want to work with this file programmatically, you can decode it using the Serde framework for Rust, but that goes beyond the scope of this tutorial.</p>"},{"location":"03_2_Creating_FROST_Secret_Shares_with_DKG_Using_Server/#summary-creating-frost-secret-shares-with-dkg-using-server","title":"Summary: Creating FROST Secret Shares with DKG Using Server","text":"<p>Creating shares with DKG, but using the ZF FROST server, demonstrates how easy FROST can be (once you get the server set up!). It's a lesson in accessibility for FROST developers.</p>"},{"location":"03_2_Creating_FROST_Secret_Shares_with_DKG_Using_Server/#whats-next","title":"What's Next","text":"<p>To review the share creation methods demonstrated in \u00a72.2, \u00a73.1, and \u00a73.2 as well as the signing methods demonstrated in \u00a72.3, \u00a73.1, and \u00a73.3, continue with \u00a73.3: ZF FROST in a Nutshell.</p> <p>Or if you're comfortable with that already, jump to another FROST advanced feature in \u00a73.4: Refreshing FROST Shares.</p>"},{"location":"03_3_ZF_FROST_in_a_Nutshell/","title":"3.3 ZF FROST in a Nutshell","text":"<p>The previous chapters demonstrated a few different ways to create shares and to create signatures. Following are some diagrams and discussions of how they work.</p>"},{"location":"03_3_ZF_FROST_in_a_Nutshell/#share-creation","title":"Share Creation","text":"<p>Creating signing shares is the first step in FROST.</p>"},{"location":"03_3_ZF_FROST_in_a_Nutshell/#tdg-creation","title":"TDG Creation","text":"<p>TDG share creation requires a centralized, trusted authority, who unilaterally splits a secret and shards it out to participants.</p> <p>See \u00a72.2 for more.</p> <p> </p>"},{"location":"03_3_ZF_FROST_in_a_Nutshell/#dkg-by-hand","title":"DKG by Hand","text":"<p>DKG is in contrast trustless, but also more complex, as most trustless protocols are.  When managing DKG by hand, each member has to communicate with every other member. (They do one broadcast each for round 1, then send an individual message to each other paricipant for round 2. This is the heart of how FROST share creation works.)</p> <p>See \u00a73.1 for more.</p> <p> </p>"},{"location":"03_3_ZF_FROST_in_a_Nutshell/#dkg-with-server","title":"DKG with Server","text":"<p>A server can take care of that communication, and greatly simplify things, and it doesn't have to be trusted, offering the best-of-both-worlds.</p> <p>See \u00a73.2 for more info.</p> <p> </p>"},{"location":"03_3_ZF_FROST_in_a_Nutshell/#signing","title":"Signing","text":"<p>Once shares have been created, members of a FROST group can sign whenever they want.</p>"},{"location":"03_3_ZF_FROST_in_a_Nutshell/#tdg-signing","title":"TDG Signing","text":"<p>ZF FROST manages TDG signing by running a <code>coordinator</code> server than the signers all connect with using their <code>participant</code> client.</p> <p>See \u00a72.3 for more.</p> <p> </p>"},{"location":"03_3_ZF_FROST_in_a_Nutshell/#dkg-signing-with-hand-created-shares","title":"DKG Signing with Hand-Created Shares","text":"<p>The exact same process can be used for signing with hand-created shares under ZZF FROST.</p>"},{"location":"03_3_ZF_FROST_in_a_Nutshell/#dkg-signing-with-server-created-shares","title":"DKG Signing with Server-Created Shares","text":"<p>The signing process for shares created with ZF FROST is a stacked affair. The same <code>frostd</code> server that managed communication during share creation now runs a signing <code>coordinator</code>.</p> <p>See \u00a73.2 for more info.</p> <p> </p>"},{"location":"03_3_ZF_FROST_in_a_Nutshell/#summary-zf-frost-in-a-nutshell","title":"Summary: ZF FROST in a Nutshell","text":"<p>ZF FROST offers a number of different ways to create shares and sign with them. This section lays them out graphically, in part for clarity, and in part to suggest models that other developers might use.</p>"},{"location":"03_3_ZF_FROST_in_a_Nutshell/#whats-next","title":"What's Next","text":"<p>Though it's not available in the ZF FROST tools, we want to overview one other advanced FROST capability in \u00a73.4: Refreshing FROST Shares</p>"},{"location":"03_4_Refreshing_FROST_Shares/","title":"3.4: Resharing Shares","text":"<p>One of the notable capabilities of FROST is the ability to refresh (or repair) shares. This functionality is not available for demo in the ZF FROST command-line tools, but developers should nonetheless be aware of the capabilities,</p>"},{"location":"03_4_Refreshing_FROST_Shares/#resharing-options","title":"Resharing Options","text":"<p>Because of the unique advantages of Schnorr (and its aggregateable signatures), FROST's signature shares can be recalculated in a variety of ways without changing the public key for a group.</p> <p>This can generally be described as repairing or refreshing the FROST shares. These processes require at least a threshold of participants (and sometimes all participants) and do not reveal any secrets to those participants (other than the ones they'd normally receive).</p> <ul> <li>Repair. Restore lost shares.</li> <li>Refresh. Update shares.</li> </ul> <p>These features allow the FROST group to be changed in a number of ways:</p> <ul> <li>Enroll. A new member can be added to a FROST group.</li> <li>Disenroll. An old member can be excluded from a FROST group.</li> <li>Change Threshold. A threshold can be increased or decreased.</li> </ul> <p>In other words, a FROST quorum can be changed in any way after it's created!</p> <p>These features are still fairly cutting edge. They have been deployed in some libraries and some apps, but should be considered experimental until fully security reviewed.</p>"},{"location":"03_4_Refreshing_FROST_Shares/#security-ramifications","title":"Security Ramifications","text":"<p>FROST refreshes do not revoke previous signing shares! In a trusted system, the threshold of signers who are refreshing the shares will afterward delete their old shares, so that the older set of shares is no longer usable. But, this is not a requirement!</p> <p>For example, Alice and Bob might update their 2-of-3 threshold shares, disenrolling Eve and enrolling Carol. They should at this point delete their old signing shares. In this case, Eve still has her signing share, and it's still valid (they always remain valid!), but Alice and Bobs' old shares are now gone, so it's impossible for Eve to achieve threshold. But if Bob acts in bad faith and does not delete his share, he can now conspire with Eve, because both of their old shares, prior to the refresh, remain usable.</p> <p>In short: the threshold of signers resharing for a FROST group must act in good faith or else the prior shares will remain usable.</p>"},{"location":"03_4_Refreshing_FROST_Shares/#refreshing-shares-programmatically","title":"Refreshing Shares Programmatically","text":"<p>Though resharing is not currently available through the ZF FROST command-line tools, you can refresh a FROST group with the ZF FROST API using <code>compute_rereshing_shares()</code> and <code>refresh_share()</code>.</p>"},{"location":"03_4_Refreshing_FROST_Shares/#summary-refreshing-shares","title":"Summary: Refreshing Shares","text":"<p>One of the advantages of FROST is that you can reshare after the fact, refreshesing, repairing, enrolling, disenrolling, or changing the threshold of your group. This creates strong resilience (because you can update a group if a share or even a member goes missing) and also creates strong flexibility (because you can change a group over time).</p>"},{"location":"03_4_Refreshing_FROST_Shares/#whats-next","title":"What's Next","text":"<p>Chapter 4: Using FROST with Bitcoin demonstrates how to use FROST signing for a real-world application: verifying Bitcoin transactions.</p>"},{"location":"04_0_FROST_and_Bitcoin/","title":"Chapter Four: FROST and Bitcoin","text":"<p>FROST has a lot of potential use cases involving cooperative action and management: members of a FROST group can jointly make decisions in an irrevocable way. Group governance and organizational decision-making could both benefit.</p> <p>However, another use case is likely to have even more immediate applicability: controlling digital assets, in particular Bitcoin. Because ZF FROST, the most mature toolset to date, is focused on Zcash, working with Bitcoin is a bit more of a challenge. However, this chapter demonstrates that it's entirely possible.</p> <p>You may also be interested in our Learning Bitcoin from the Command Line course, though it's not required for this chapter.</p>"},{"location":"04_0_FROST_and_Bitcoin/#objectives-for-this-chapter","title":"Objectives for this Chapter","text":"<p>After working through this chapter, a reader will be able to:</p> <ul> <li>Design Bitcoin Transactions using Command Line Tools</li> <li>Sign Bitcoin Transactions using a FROST Group</li> </ul> <p>Supporting objectives include the ability to:</p> <ul> <li>Understand Partially Signed Bitcoin Transactions (PSBTs)</li> <li>Understand How Bitcoin Uses Schnorr Signatures</li> </ul>"},{"location":"04_0_FROST_and_Bitcoin/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Section One: Installing the Bitcoin Tools</li> <li>Section Two: Signing PSBTs with FROST</li> </ul>"},{"location":"04_1_Installing_Bitcoin_Tools/","title":"4.1: Installing Bitcoin Tools","text":"<p>Though signing Bitcoin transactions with a FROST group is now possible, none of the command line tools do quite what's required. Doing so instead requires using a branch of the ZF FROST Tools and a few hand constructed helpers, along with the excellent Bitcoin command-line tool, BDK, the Bitcoin Development Kit.</p>"},{"location":"04_1_Installing_Bitcoin_Tools/#equipment-inventory","title":"Equipment Inventory","text":"<p>This section will take you through the installation of the following tools, which together will allow you to sign and send a Bitcoin transaction:</p> <ul> <li>The Bitcoin Core client &amp; server</li> <li>The Bitcoin Development Kit</li> <li>Our version of the ZF FROST Tools with Secp256K1-TR Ciphersuite Support</li> <li>... Using the Taproot Tweak Branch</li> <li>The <code>sighash-helper</code> Tool   </li> <li>The <code>psbt-sig-attach</code> Tool</li> <li>The <code>jq</code> and <code>tq</code> stream editors</li> </ul> <p>Obviously, this is a complex process, though this tutorial will take you right through it. In walking through this process, you'll see not only how everything works, but also why it's very important to make this type of procedure much easier, to aid in the accessibility and so the usage of FROST.</p>"},{"location":"04_1_Installing_Bitcoin_Tools/#installing-bitcoin-core","title":"Installing Bitcoin Core","text":"<p>You will need Bitcoin Core to create and sign transactions.</p> <p>We would usually suggest Gordian Server as a best solution for running a Bitcoin node, but that is limited to Macs, and it offers more features than are really necessary for the simple regtest example here.</p> <p>So instead we suggest downloading the appropriate version of Bitcoin Core for your OS:</p> <p>https://bitcoin.org/en/download</p> <p>Some pacakage managers may make this install even easier. For example, the following will install Bitcoin Core on your Mac if you use the Homebrew package installer:</p> <pre><code>% brew install bitcoin\n</code></pre> <p>This should install both <code>bitcoind</code> (the server) and <code>bitcoin-cli</code> (a command-line client).</p>"},{"location":"04_1_Installing_Bitcoin_Tools/#installing-bdk-cli","title":"Installing bdk-cli","text":"<p>Though Bitcoin has its own command-line app (<code>bitcoin-cli</code>), this example also uses <code>bdk-cli</code>, the Bitcoin Dev Kit CLI. It's primarily used for work involving the FROST wallet, both because <code>bitcoin-cli</code> doesn't work well with addresses not created by it and because examples are simpler if you have two different apps for the two different wallets: <code>bitcoin-cli</code> is used for the regular Bitcoin wallet and <code>bdk-cli</code> for the FROST Bitcoin wallet.</p> <p>This is a <code>bdk-cli</code> crate, making this an easy install.</p> <pre><code>% cargo install bdk-cli --features rpc\n</code></pre> <p>Note that the <code>rpc</code> feature must be included to allow connection to the <code>bitcoind</code> server that you just installed.</p> <p>:book: What is RPC? RPC is \"Remote Procedure Call\", a protocol used to communicate between processes on different systems (or even on the same system). It includes an authorization protocol, which allows the remote server to authenticate a user connecting to it, using a user name and password.</p>"},{"location":"04_1_Installing_Bitcoin_Tools/#installing-the-blockchain-commons-version-of-frost","title":"Installing the Blockchain Commons Version of FROST","text":"<p>Blockchain Commons has patched the ZF FROST tools to offer the improvements required to sign Bitcoin transactions. This comes in two parts: one adds secp256k1-tr as a ciphersuite; and the other supplements that by incorporating the Taproot methodology for tweaking keys.</p> <p>:book: What is secp256k1? Bitcoin uses elliptic curve cryptography (ECC) for its core cryptographic functions, such as creating a public key from a private key. Any ECC calculations are done with a specific elliptic curve. The curve used by Bitcoin for its ECC calculations is secp256k1.</p> <p>:book: What is Taproot? Taproot was an upgrade to Bitcoin introduced in November 2021. It allows for the use of Schnorr signatures (including FROST signatures) with a new P2TR type of transaction. The P2TR transaction allows public keys and scripts to be secretly combined into a single <code>scriptPubKey</code> that locks a Bitcoin transaction. This is done with a \"tweak\".</p> <p>:book: So what is secp256k1-tr? It's a Schnorr signature using the secp256k1 curve that supports Taproot (and so FROST).</p> <p>You can install the updated version of the ZF FROST tools that includes both of these elements as follows:</p> <pre><code>% git clone https://github.com/BlockchainCommons/zcash-frost-tools\n% cd zcash-frost-tools \n% git checkout taproot-tweak\n% cargo install --path frost-client &amp;&amp; cargo install --path frostd\n% cd ..\n</code></pre> <p>This will entirely replace the version of the ZF FROST tools that you installed in \u00a72.1: Installing the FROST Tools. You should see messages like the following indicating this during the installation:</p> <pre><code>Replacing /Users/ShannonA/.cargo/bin/coordinator\nReplacing /Users/ShannonA/.cargo/bin/dkg\nReplacing /Users/ShannonA/.cargo/bin/frost-client\nReplacing /Users/ShannonA/.cargo/bin/participant\nReplacing /Users/ShannonA/.cargo/bin/trusted-dealer\n\n...\n\nReplacing /Users/ShannonA/.cargo/bin/frostd\nReplaced package `frostd v0.1.0 (/Users/ShannonA/Documents/GitHub/FROST/frost-tools/frostd)` with `frostd v0.1.0 (/Users/ShannonA/Documents/GitHub/Blockchain-Commons/zcash-frost-tools/frostd)` (executable `frostd`)\n</code></pre> <p>The version numbers will be the same, but looking at your copies of the apps should indicate an update via new timestamps:</p> <pre><code>% ls -lagh `which frost-client`\n-rwxr-xr-x  1 staff    10M Nov  4 11:13 /Users/ShannonA/.cargo/bin/frost-client\n% ls -lagh `which frostd`\n-rwxr-xr-x  1 staff   7.0M Nov  4 11:14 /Users/ShannonA/.cargo/bin/frostd\n</code></pre>"},{"location":"04_1_Installing_Bitcoin_Tools/#creating-the-sighash-helper-helper-tool","title":"Creating the <code>sighash-helper</code> Helper Tool","text":"<p>Even <code>bdk-cli</code> and <code>bitcoin-cli</code> don't have everything required to sign a FROST transaction!</p> <p>To start with, there's no way to extract a signature hash from a transaction so that it can be signed by the ZF FROST tools. The <code>sighash-helper</code> tool is a simple Rust program that does so. You'll quickly create it by hand.</p> <p>First, create a Rust project:</p> <pre><code>% cargo new sighash-helper --bin\nCreating binary (application) `sighash-helper` package\n</code></pre> <p>This will create two files: <code>Cargo.toml</code>, which details the program and its dependencies; and <code>src/main.rs</code>, which contains the actual code for the program.</p> <p>You then need to add the following to the <code>[dependencies]</code> section of the <code>Cargo.toml</code>. If the section is currently empty (likely the case for a default file), you can do the following:</p> <pre><code>% cd sighash-helper\n% cat &gt;&gt; Cargo.toml\nbdk = { version = \"0.30.2\", default-features = false, features = [\"std\"] }\n</code></pre> <p>You'll need to hit ^D at the end to close out the <code>cat</code>.</p> <p>Afterward your file should look something like:</p> <pre><code>[package]\nname = \"sighash-helper\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\nbdk = { version = \"0.30.2\", default-features = false, features = [\"std\"] }\n</code></pre> <p>You should then input the following into <code>src/main.rs</code>:</p> <pre><code>use std::io::{self, Read};\nuse std::str::FromStr;\n\nuse bdk::bitcoin::psbt::PartiallySignedTransaction as Psbt;\nuse bdk::bitcoin::sighash::{Prevouts, SighashCache, TapSighashType};\n\nfn main() {\n    // 1. read the base\u201164 PSBT from stdin\n    let mut b64 = String::new();\n    io::stdin().read_to_string(&amp;mut b64).unwrap();\n    let psbt = Psbt::from_str(b64.trim()).expect(\"valid base64 PSBT\");\n\n    // 2. assume exactly one input (enforced by the demo)\n    let tx = &amp;psbt.unsigned_tx;\n\n    // 3. clone the single witness_utxo so it lives long enough\n    let txout = psbt.inputs[0]\n        .witness_utxo\n        .as_ref()\n        .expect(\"witness_utxo present\")\n        .clone();\n    let prevouts_arr = [txout];                 // concrete array on the stack\n    let prevouts = Prevouts::All(&amp;prevouts_arr);\n\n    // 4. compute Taproot key\u2011path sighash\n    let mut cache = SighashCache::new(tx);\n    let msg = cache\n        .taproot_key_spend_signature_hash(0, &amp;prevouts, TapSighashType::Default)\n        .expect(\"sighash\");\n\n    // 5. print the 32\u2011byte message as hex\n    println!(\"{:064x}\", msg);\n}\n</code></pre> <p>You can enter this with <code>cat &gt; src/main.rs</code> or use your favorite editor.</p> <p>You're now ready to install your <code>sighash-helper</code></p> <pre><code>% cargo install --path .\n% cd ..\n</code></pre>"},{"location":"04_1_Installing_Bitcoin_Tools/#creating-the-psbt-sig-attach-helper-tool","title":"Creating the <code>psbt-sig-attach</code> Helper Tool","text":"<p>There's also no way to add an arbitrary signature to a PSBT. (<code>bitcoin-cli</code> and <code>bdk-cli</code> both do so internally.)  This requires the creation of another helper tool, <code>psbt-sig-attach</code>.</p> <pre><code>% cargo new psbt-sig-attach --bin\nCreating binary (application) `psbt-sig-attach` package\n</code></pre> <p>Again, add dependencies:</p> <pre><code>% cd psbt-sig-attach\n% cat &gt;&gt; Cargo.toml\nbdk    = { version = \"0.30.2\", default-features = false, features = [\"std\"] }\nbase64 = \"0.22.1\"\nhex    = \"0.4\"\nbitcoin = \"0.30.2\"\n</code></pre> <p>Afterward, <code>Cargo.toml</code> should look like this:</p> <pre><code>[package]\nname = \"psbt-sig-attach\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\nbdk    = { version = \"0.30.2\", default-features = false, features = [\"std\"] }\nbase64 = \"0.22.1\"\nhex    = \"0.4\"\nbitcoin = \"0.30.2\"\n</code></pre> <p>Then, replace <code>src/main.rs</code> with the following:</p> <pre><code>use std::io::{self, Read};\nuse std::str::FromStr;\n\nuse bitcoin::{\n    psbt::PartiallySignedTransaction as Psbt,\n    secp256k1::schnorr::Signature as SchnorrSig,\n    sighash::TapSighashType,\n    taproot::Signature as TaprootSignature,\n};\nuse hex::FromHex;\n\nfn main() {\n    // r||s hex comes as first CLI arg\n    let sig_hex = std::env::args()\n        .nth(1)\n        .expect(\"usage: psbt-sig-attach &lt;64-byte r||s hex&gt;\");\n    let sig_vec = Vec::&lt;u8&gt;::from_hex(sig_hex.trim()).expect(\"hex sig\");\n    assert_eq!(sig_vec.len(), 64, \"need 64-byte Schnorr sig\");\n\n    // wrap in TaprootSignature with default sighash flag\n    let tap_sig = TaprootSignature {\n        sig: SchnorrSig::from_slice(&amp;sig_vec).expect(\"schnorr sig\"),\n        hash_ty: TapSighashType::Default,\n    };\n\n    // read base-64 PSBT from stdin\n    let mut b64 = String::new();\n    io::stdin().read_to_string(&amp;mut b64).unwrap();\n    let mut psbt = Psbt::from_str(b64.trim()).expect(\"base64 PSBT\");\n\n    // insert signature in input 0\n    psbt.inputs[0].tap_key_sig = Some(tap_sig);\n\n    // write updated PSBT as base-64\n    println!(\"{}\", psbt.to_string());\n}\n</code></pre> <p>Finally, install and leave the project behind:</p> <pre><code>% cargo install --path .\n% cd ..\n</code></pre>"},{"location":"04_1_Installing_Bitcoin_Tools/#installing-jq-and-tq","title":"Installing <code>jq</code> and <code>tq</code>","text":"<p><code>jq</code> and <code>tq</code> are command-line stream editors. <code>jq</code> makes it easy to manipulate JSON files and <code>tq</code> makes it easy to manipulate TOML files.</p> <p>You should be able to install <code>jq</code> with a package manager.</p> <p>For UNIX:</p> <pre><code>% apt-get install jq\n</code></pre> <p>For Homebrew on Mac:</p> <pre><code>% brew install jq\n</code></pre> <p>You can also install <code>jq</code> directly from jqlang.org.</p> <p>See the interlude in Learning Bitcoin from the Command Line if you're interested in learning more about <code>jq</code>.</p> <p>You should have already installed <code>tq</code> in \u00a73.2. If you didn't refer to \"Installing tomlq\" there for the easy instructions.</p>"},{"location":"04_1_Installing_Bitcoin_Tools/#checking-your-inventory","title":"Checking Your Inventory","text":"<p>You can check your inventory on most systems with the <code>which</code> command. If anything is missing, you'll need to either consult the appropriate section, above, for how to install, or perhaps just make sure your $PATH includes where the install happened.</p> <pre><code>% which bitcoind\n/opt/homebrew/bin/bitcoind\n% which bitcoin-cli\n/opt/homebrew/bin/bitcoin-cli\n% which bdk-cli\n/Users/ShannonA/.cargo/bin/bdk-cli\n% which frost-client\n/Users/ShannonA/.cargo/bin/frost-client\n% which frostd\n/Users/ShannonA/.cargo/bin/frostd\n% which sighash-helper\n/Users/ShannonA/.cargo/bin/sighash-helper\n% which psbt-sig-attach\n/Users/ShannonA/.cargo/bin/psbt-sig-attach\n% which jq\n/opt/homebrew/bin/jq\n% which tq\n/Users/ShannonA/.cargo/bin/tq\n</code></pre>"},{"location":"04_1_Installing_Bitcoin_Tools/#summary-installing-bitcoin-tools","title":"Summary: Installing Bitcoin Tools","text":"<p>To get ready for FROST signing of a Bitcoin transaction, you need to install:</p> <ul> <li>bitcoind: The server that will run your <code>regtest</code> environment.</li> <li>bitcoin-cli: Bitcoin's app, which will manage your basic Bitcoin wallet.</li> <li>bdk-cli: The Bitcoin Dev Kit app, which will manage your FROST Bitcoin wallet.</li> <li>ZF FROST Tools: An updated version of <code>frostd</code> and <code>frost-client</code>.</li> <li>Helper Tools: Two small apps, <code>sighash-helper</code> and <code>psbt-sig-attach</code>, which are required to extract info from a PSBT and then import into it.</li> <li>tq &amp; jq: Stream editors for structured JSON and TOML files.</li> </ul>"},{"location":"04_1_Installing_Bitcoin_Tools/#whats-next","title":"What's Next","text":"<p>You'll put this to use in \u00a74.2: Signing PSBTs with FROST.</p>"},{"location":"04_2_Signing_PSBTs_with_FROST/","title":"4.2: Signing PSBTs with FROST","text":"<p>You've now got all the tools you need to successfully send a Bitcoin transaction signed by a FROST group. But it's still going to take some work! This section will take you through the following major steps:</p> <p>Setup:</p> <ol> <li>Setting Up Your Work Space</li> <li>Starting a Regtest Daemon</li> <li>Creating and Funding a Bitcoin Wallet</li> <li>Creating a FROST Group with DKG</li> <li>Creating a FROST Bitcoin Wallet</li> <li>Sending Funds to the FROST Wallet</li> </ol> <p>Signing:</p> <ol> <li>Creating an Unsigned PSBT for the FROST Wallet</li> <li>Generating a Signature using the FROST Group</li> <li>Signing the PSBT using the FROST Group</li> <li>Finalizing and Sending the PSBT</li> </ol>"},{"location":"04_2_Signing_PSBTs_with_FROST/#step-1-setting-up-your-work-space","title":"Step 1: Setting Up Your Work Space","text":"<p>First, set some shell variables that will make the rest of this tutorial easier.</p> <pre><code>DEMO_DIR=`pwd`/frost-signing-demo\nREG_DIR=\"$DEMO_DIR/regular-wallet\"\nFROST_DIR=\"$DEMO_DIR/frost-wallet\"\nNETWORK=regtest\nRPC_URL=127.0.0.1:18443 \nRPC_USER=test\nRPC_PASS=test\nRPC_AUTH=\"$RPC_USER:$RPC_PASS\"\n</code></pre> <p>Then create your directories:</p> <pre><code>mkdir -p \"$DEMO_DIR\" \"$REG_DIR\" \"$FROST_DIR\"\ncd \"$DEMO_DIR\"\n</code></pre>"},{"location":"04_2_Signing_PSBTs_with_FROST/#step-2-starting-a-regtest-daemon","title":"Step 2: Starting a Regtest Daemon","text":"<p>This example uses the \"regtest\" network as a testing environment for Bitcoin rather than working with real funds.</p> <p>:book: What is Regtest? Bitcoin offers three different testing environments: testnet, signet, and regtest. Testnet works much like the regular Bitcoin network, but its coins have no value. Signet requires blocks be signed. Regtest gives the developer complete control over block creation. This example uses regtest for its testing so that you don't have to go to coin faucets or wait for transactions to be collected into blocks.</p> <p>To initiate regtest, start the Bitcoin Core <code>bitcoind</code>. Set flags to use the regtest network (<code>-regtest</code>), to run in the background (<code>-daemon</code>), to set an RPC user and password (<code>-rpcuser</code> and <code>-rpcpassword</code>), and to set a fallback transaction fee, so that your transactions will go through (<code>-fallbackfee</code>).</p> <pre><code>bitcoind -regtest -daemon -rpcuser=$RPC_USER -rpcpassword=$RPC_PASS -fallbackfee=0.00001\n</code></pre> <p>:warning: WARNING: Obviously, you would never use the <code>-rpcuser</code> and <code>-rpcpassword</code> arguments from the command-line for a real-world deployment, as they could be seen in the process list. But, they're fine for a test usage with regtest.</p> <p>:information_source: NOTE: You'd usually set up a <code>bitcoin.conf</code> file that would records things like your <code>$RPC_USER</code>, your <code>$RPC_PASS</code>, and the fact that you're using the regtest network. These examples will just include all of that material on the command line, which makes them longer, but also means you don't have to figure out where your configuration file is, which is probably preferred for a short Bitcoin example.</p>"},{"location":"04_2_Signing_PSBTs_with_FROST/#step-3-creating-and-funding-a-bitcoin-address","title":"Step 3: Creating and Funding a Bitcoin Address","text":"<p>You'll first need to create your default regular Bitcoin wallet. This used to happen by default with <code>bitcoin-cli</code>, but no longer does.</p> <pre><code>bitcoin-cli -rpcuser=$RPC_USER \\\n            -rpcpassword=$RPC_PASS \\\n            -regtest \\\n            createwallet regtest || \\\nbitcoin-cli -rpcuser=$RPC_USER \\\n            -rpcpassword=$RPC_PASS \\\n            -regtest \\\n        loadwallet regtest\n\n{\n  \"name\": \"regtest\"\n}\n</code></pre> <p>You can now create an address in that wallet:</p> <pre><code>REG_ADDRESS=$(bitcoin-cli -rpcuser=$RPC_USER \\\n                -rpcpassword=$RPC_PASS \\\n                -regtest \\\n                getnewaddress)\n</code></pre> <p>Finally, you can mine the genesis block to that address:</p> <pre><code>bitcoin-cli -rpcuser=$RPC_USER \\\n              -rpcpassword=$RPC_PASS \\\n          -regtest \\                               \n          generatetoaddress 1 $REG_ADDRESS\n[\n  \"51817c46a4ba678ce1e64970eb1978e8827b7272409b877c3abe4849b01ae68b\"\n]\n</code></pre> <p>The <code>generatetoaddress</code> command is one of the magic regtest commands that lets you manipulate blocks to more easily test out Bitcoin. In this case, you are mining a (empty) block with the block reward for doing so going to the indicated address. So this command mines 1 block to your $REG_ADDRESS. With the 50 BTC reward for the first block, you're rich! (In fake regtest bitcoin.)</p> <p>Afterward, you will advance the blockchain by another 100 blocks:</p> <pre><code>bitcoin-cli -rpcuser=$RPC_USER \\\n              -rpcpassword=$RPC_PASS \\\n              -regtest \\\n              -generate 100\n</code></pre> <p>:book: Why Mine 101 Blocks? The reward a miner gets for mining a block is called the \"coinbase transaction\". It can only be spent when it's 100 blocks deep in the blockchain. After you mine 101 blocks, the first block you mined is 100 blocks deep, which means you can now spend the 50 Bitcoins you claimed for it.</p> <p>At this point, mining those additional 100 blocks will send the coinbase transactions to your wallet, even without the <code>generatetoaddress</code> command: they'll show up as you continue to advance blocks.</p> <p>Before you continue, you should verify you have coins to spend:</p> <pre><code>bitcoin-cli -rpcuser=$RPC_USER -rpcpassword=$RPC_PASS -regtest getbalance\n50.00000000\n</code></pre>"},{"location":"04_2_Signing_PSBTs_with_FROST/#step-4-creating-a-frost-group-with-dkg","title":"Step 4: Creating a FROST Group with DKG","text":"<p>You can now create a Frost group using DKG, just like you did in \u00a73.2 with one notable difference: you're going to be using the <code>secp256k1-tr</code> ciphersuite. Otherwise, everything else is identical.</p> <p>Here's the rapid-fire summary (with the reminder that in a real setup, each of the users should be on a different machine):</p> <p>Create the user credential files:</p> <pre><code>cd frost-wallet\nfrost-client init -c alice.toml\nfrost-client init -c bob.toml\nfrost-client init -c eve.toml\n</code></pre> <p>Extract the public keys:</p> <pre><code>ALICE_PUBKEY=$(tq -f alice.toml -r 'communication_key.pubkey')\nALICE_CONTACT=$(frost-client export --name \"Alice\" -c alice.toml 2&gt;&amp;1 | tail -1)\nBOB_PUBKEY=$(tq -f bob.toml -r 'communication_key.pubkey')\nBOB_CONTACT=$(frost-client export --name \"Bob\" -c bob.toml 2&gt;&amp;1 | tail -1)\nEVE_PUBKEY=$(tq -f eve.toml -r 'communication_key.pubkey') \nEVE_CONTACT=$(frost-client export --name \"Eve\" -c eve.toml 2&gt;&amp;1 | tail -1)\n</code></pre> <p>Have each of the users transmit the information on their public keys to all the other users.</p> <p>Have each user import the other users' info into their credentials file:</p> <pre><code>frost-client import -c alice.toml $BOB_CONTACT\nfrost-client import -c alice.toml $EVE_CONTACT\n\nfrost-client import -c bob.toml $ALICE_CONTACT\nfrost-client import -c bob.toml $EVE_CONTACT\n\nfrost-client import -c eve.toml $ALICE_CONTACT\nfrost-client import -c eve.toml $BOB_CONTACT\n</code></pre> <p>Make sure your <code>frostd</code> server is running with its certificate. If you skipped over that in \u00a73.2, you can jump back there to \"Prepare the Server\".</p> <p>Alice then runs the <code>frost-client</code> with the other <code>PUBKEY</code>s and the new <code>secp256k1-tr</code> cipher:</p> <pre><code>frost-client dkg -d \"Bitcoin DKG: Alice, Bob, Eve\" \\\n-s 127.0.0.1:2744 \\\n-S $BOB_PUBKEY,$EVE_PUBKEY \\\n-t 2 \\\n-C \"secp256k1-tr\" \\\n-c alice.toml\n</code></pre> <p>Bob runs the client without the <code>PUBKEY</code>s.:</p> <pre><code>frost-client dkg -d \"DKG: Alice, Bob, Eve\" \\\n-s 127.0.0.1:2744 \\\n-t 2 \\\n-C \"secp256k1-tr\" \\\n-c bob.toml\n</code></pre> <p>Eve runs the client:</p> <pre><code>frost-client dkg -d \"DKG: Alice, Bob, Eve\" \\\n-s 127.0.0.1:2744 \\\n-t 2 \\\n-C \"secp256k1-tr\" \\\n-c eve.toml\n</code></pre> <p>As before, the clients will do all the talking among themselves (via the server) and then all the info will be output to the credentials files.</p> <p>:information_source: NOTE: You installed two updates to the ZF FROST tools in \u00a74.1. The first of them, which adds secp256k1-tr as a ciphersuite, is used here. (As it happens, the second update is also hiding out the background, but more on that when we put it to more complete use during the signing ceremony.)</p> <p>Here's what Alice's credentials now look like:</p> <pre><code>version = 0\n\n[communication_key]\nprivkey = \"51e60d2eb443d1955a862bc355e7ac5bbaea3fe171f056c4604748e9d1eea82b\"\npubkey = \"9ed1c448119a6d1441aa2ca2fd584691ff122339e870780b247941cfa06d8d75\"\n\n[contact.Bob]\nname = \"Bob\"\npubkey = \"61c0af67bea157aad7b0e8f4e27353281159fb747d91c48d39328dcdec4c6272\"\n\n[contact.Eve]\nname = \"Eve\"\npubkey = \"fe36fe0b20ce9eff3e2050b3e24ce0e57b093425b8b5980c222f9e6d7df14b30\"\n\n[group.02213e68e3d071ebce9c491114dcbdc1ee76ed3f52b30f05b5f27d36f6fdf37c85]\ndescription = \"Bitcoin DKG: Alice, Bob, Eve\"\nciphersuite = \"FROST-secp256k1-SHA256-TR-v1\"\npublic_key_package = \"00230f8ab303348fd8ec2919a79d9976d5cf79626a74e99eb1004c05b115cb72f7e89f87fb2a0388881328732b7f62744e253bc980bd605bf75cefb18116a0d856d83e04857982e6aaeb3554d0a68d930c66bf206f63dc9306d358bfa18cf4712cbe3693097adc02bc496dfe1914c323b716f788130864d181a5aa4bb0154702d501941b310986fceeec13b5314aa5b0a8ce12dc6786a92a7f571cbaf5d2de1307d78ee98a7f1d1802fc61ad07349a15ceb8c60a0ba09c6c4f50f032f815495e5d865e158f5ac83629025106c0bcb903ba03587afbf2c769b2fcee2c8518ac383ff0849abd6bf46ba7eb\"\nkey_package = \"00230f8ab3348fd8ec2919a79d9976d5cf79626a74e99eb1004c05b115cb72f7e89f87fb2a739c7d396e81a7929843d02d75aff78b5dfbe1c4c72d1c5c14eb0043b7100a910388881328732b7f62744e253bc980bd605bf75cefb18116a0d856d83e04857982025106c0bcb903ba03587afbf2c769b2fcee2c8518ac383ff0849abd6bf46ba7eb02\"\nserver_url = \"127.0.0.1:2744\"\ninternal_key = [\n    81,\n    6,\n    192,\n    188,\n    185,\n    3,\n    186,\n    3,\n    88,\n    122,\n    251,\n    242,\n    199,\n    105,\n    178,\n    252,\n    238,\n    44,\n    133,\n    24,\n    172,\n    56,\n    63,\n    240,\n    132,\n    154,\n    189,\n    107,\n    244,\n    107,\n    167,\n    235,\n]\n\n[group.02213e68e3d071ebce9c491114dcbdc1ee76ed3f52b30f05b5f27d36f6fdf37c85.participant.348fd8ec2919a79d9976d5cf79626a74e99eb1004c05b115cb72f7e89f87fb2a]\nidentifier = \"348fd8ec2919a79d9976d5cf79626a74e99eb1004c05b115cb72f7e89f87fb2a\"\npubkey = \"9ed1c448119a6d1441aa2ca2fd584691ff122339e870780b247941cfa06d8d75\"\n\n[group.02213e68e3d071ebce9c491114dcbdc1ee76ed3f52b30f05b5f27d36f6fdf37c85.participant.e6aaeb3554d0a68d930c66bf206f63dc9306d358bfa18cf4712cbe3693097adc]\nidentifier = \"e6aaeb3554d0a68d930c66bf206f63dc9306d358bfa18cf4712cbe3693097adc\"\npubkey = \"fe36fe0b20ce9eff3e2050b3e24ce0e57b093425b8b5980c222f9e6d7df14b30\"\n\n[group.02213e68e3d071ebce9c491114dcbdc1ee76ed3f52b30f05b5f27d36f6fdf37c85.participant.eeec13b5314aa5b0a8ce12dc6786a92a7f571cbaf5d2de1307d78ee98a7f1d18]\nidentifier = \"eeec13b5314aa5b0a8ce12dc6786a92a7f571cbaf5d2de1307d78ee98a7f1d18\"\npubkey = \"61c0af67bea157aad7b0e8f4e27353281159fb747d91c48d39328dcdec4c6272\"\n</code></pre> <p>Most importantly, note that this enew FROST group uses the Bitcoin-compatible ciphersuite:</p> <pre><code>ciphersuite = \"FROST-secp256k1-SHA256-TR-v1\"\n</code></pre> <p>Again, this part of the process was identical to what was in \u00a73.2 other than the use of the \"secp256k1-tr\" ciphersuite on the <code>frost-client dkg</code> command lines.</p>"},{"location":"04_2_Signing_PSBTs_with_FROST/#step-5-creating-a-frost-bitcoin-wallet","title":"Step 5: Creating a FROST Bitcoin Wallet","text":"<p>Though you now have a Bitcoin-ready FROST signing group, you still need to create a Bitcoin address for your FROST key. To do so, you must first extract some information about your FROST group.</p> <p>The following does so from Alice's credentials file.</p> <pre><code>GROUP_ID=$(grep -oE '^\\[group\\.[0-9a-f]+' alice.toml | head -1 | sed 's/^\\[group\\.//')\nPUBKEY_PKG=$(tq -f alice.toml -r group.$GROUP_ID.public_key_package)\nFROST_AGG_KEY=$(echo $PUBKEY_PKG | tail -c 65)\n</code></pre> <p>Note that the last variable (<code>FROST_AGG_KEY</code>) depends on knowing that the group verifying key is the last 32 bytes of the <code>public_key_package</code>.</p> <p>With that in hand, you create a descriptor for this address:</p> <pre><code>FROST_EXT_DESC=\"tr($FROST_AGG_KEY)\"\n</code></pre> <p>:book: What is a Descriptor? In the bad-'ole days, there was a proliferating set of methods for describing Bitcoin wallets. As different derivation methods appeared, this became problematic because it increased the odds of losing access to funds: you might know a seed or an HD key, but not how to get to the derivative key where funds were actually stored! BIP 380 defined \"output descriptors\", a new methodology for defining wallets that included key material, derivation material, and methodology.</p> <p>:book: What is a \"tr()\" descriptor? A \"tr()\" descriptor defines a Taproot address, per BIP 386. It takes a key as an argument that may have been overlaid with a tree of additional ways to unlock an address. It defines a P2TR address.</p> <p>With that variable, you can now use <code>bitcoin-cli</code> to output the Taproot address linked to your group verifying key. (Due to the power of output descriptors, essentially all you're doing is asking for the address associated with \"tr(your-public-key)\".)</p> <p>This comes in two parts. First you have to fully qualify the descriptor by adding a checksum: <code>bitcoin-cli</code> requires this for all work with descriptors. Then you can ask <code>bitcoin-cli</code> to generate the address.</p> <p>You can do this with the following commands:</p> <pre><code>FROST_EXT_DESC_WITH_CS=$(bitcoin-cli -rpcuser=$RPC_USER -rpcpassword=$RPC_PASS -regtest getdescriptorinfo $FROST_EXT_DESC | jq -r .descriptor)\nFROST_ADDRESS=$(bitcoin-cli -rpcuser=$RPC_USER -rpcpassword=$RPC_PASS -regtest deriveaddresses $FROST_EXT_DESC_WITH_CS | jq -r '.[0]')\n</code></pre> <p>That should convert your FROST group verifying key (public key) into a valid Bitcoin address:</p> <pre><code>% echo $FROST_ADDRESS\nbcrt1pyylx3c7sw84ua8zfzy2de0wpaemw606jkv8std0j05m0dl0n0jzsuv3mk6\n</code></pre>"},{"location":"04_2_Signing_PSBTs_with_FROST/#step-6-sending-funds-to-the-frost-wallet","title":"Step 6: Sending Funds to the FROST Wallet","text":"<p>You're now ready to send funds from your Bitcoin wallet to your FROST wallet. This is simply done with the <code>sendtoaddress command</code>:</p> <pre><code>bitcoin-cli -rpcuser=$RPC_USER \\\n        -rpcpassword=$RPC_PASS \\\n        -regtest \\\n        sendtoaddress $FROST_ADDRESS 10.0\n</code></pre> <p>You'll get back a transaction ID:</p> <pre><code>f11f5188bf65f24aac5d4f6e943e0e2def511b2188bc0aec43291b1880a5864f\n</code></pre> <p>Since you're living in a regtest world, you need to create a new block to log that transaction:</p> <pre><code>bitcoin-cli -rpcuser=$RPC_USER \\\n              -rpcpassword=$RPC_PASS \\\n              -regtest \\\n              -generate 1\n</code></pre> <p>Before you move on, you should make sure the transfer of funds occurred as expected.</p> <p>First, you can check the balance on your regular Bitcoin wallet:</p> <pre><code>bitcoin-cli -rpcuser=$RPC_USER -rpcpassword=$RPC_PASS -regtest getbalance\n\n89.99999835\n</code></pre> <p>The new balance is 89.99999835 BTC = 50 BTC (original balance) - 10 BTC (sent) - 0.00000165 BTC (fallback fee) + 50 BTC (coinbase for block #2, since we're now on block #102).</p> <p>As for the FROST wallet, you'll be using <code>bdk-cli</code> to look at that, since <code>bitcoin-cli</code> doesn't do a good job of working with addresses that aren't in its wallet (and since it's convenient to use two different apps to control your two different wallets, particularly in a tutorial).</p> <p>BDK wants a bit more information on its wallets, which it divides between an \"external descriptor\" (which you've already defined) and an \"internal descriptor\", so you'll need to set that first.</p> <pre><code>FROST_INT_DESC=\"tr($FROST_AGG_KEY,pk($FROST_AGG_KEY))\"\n</code></pre> <p>:book: What are External &amp; Internal Descriptors? BDK uses a classic methodology of separating addresses that are meant to be given out (external) and those only intended for change (internal).</p> <p>:book: What is a \"pk()\" descriptor? A \"pk()\" descriptor defines an address by its public key, per BIP 381. it describes a classic P2PK address.</p> <p>First, you must ask BDK to sync a wallet with those descriptors:</p> <pre><code>bdk-cli \\\n  --network \"$NETWORK\" \\\n  --datadir \"$FROST_DIR\" \\\n  wallet \\\n    --client-type rpc \\\n    --database-type sqlite \\\n    --url \"$RPC_URL\" \\\n    -a \"$RPC_AUTH\" \\\n    --ext-descriptor \"$FROST_EXT_DESC\" \\\n    --int-descriptor \"$FROST_INT_DESC\" \\\n    sync\n</code></pre> <p>Your <code>bdk-cli</code> commands will generally require defining a <code>wallet</code> and then giving it a command, like <code>sync</code>. For example, to check that the funds have gone through, you now access <code>wallet ... balance</code>.</p> <pre><code>bdk-cli \\\n  --network \"$NETWORK\" \\\n  --datadir \"$FROST_DIR\" \\\n  wallet \\\n    --client-type rpc \\\n    --database-type sqlite \\\n    --url \"$RPC_URL\" \\\n    -a \"$RPC_AUTH\" \\\n    --ext-descriptor \"$FROST_EXT_DESC\" \\\n    --int-descriptor \"$FROST_INT_DESC\" \\\n    balance\n</code></pre> <p>Here's the result:</p> <pre><code>{\n  \"satoshi\": {\n    \"confirmed\": 1000000000,\n    \"immature\": 0,\n    \"trusted_pending\": 0,\n    \"untrusted_pending\": 0\n  }\n}\n</code></pre> <p>The Bitcoin wallet controlled by your FROST group has 10 BTC! You're down with the set up (at last!) and now ready for a threshold of FROST members to create and sign a transaction!</p>"},{"location":"04_2_Signing_PSBTs_with_FROST/#step-7-creating-an-unsigned-psbt-for-the-frost-wallet","title":"Step 7: Creating an Unsigned PSBT for the FROST Wallet","text":"<p>You're now ready to create a transaction sending some funds back from the FROST wallet to the Bitcoin wallet, which will demonstrate using a FROST group signature for a Bitcoin transaction.</p> <p>To do so, you first must generate a new address for receipt on your regular Bitcoin wallet:</p> <pre><code>REG_NEW_ADDRESS=$(bitcoin-cli -rpcuser=$RPC_USER \\                   \n                            -rpcpassword=$RPC_PASS \\\n                            -regtest \\\n                            getnewaddress)\n</code></pre> <p>:information_source: NOTE: It is best practice to generate a new address any time you receive digital funds.</p> <p>You can now create a PSBT that sends 100,000,000 satoshis (1 BTC) from your FROST wallet to that address on your regular Bitcoin wallet:</p> <pre><code>AMOUNT=100000000\nUNSIGNED_PSBT=$(bdk-cli \\\n  --network \"$NETWORK\" \\\n  --datadir \"$FROST_DIR\" \\\n  wallet \\\n    --client-type rpc \\\n    --url \"$RPC_URL\" \\\n    -a \"$RPC_AUTH\" \\\n    --database-type sqlite \\\n    --ext-descriptor \"$FROST_EXT_DESC\" \\\n    --int-descriptor \"$FROST_INT_DESC\" \\\n    create_tx \\\n      --to ${REG_NEW_ADDRESS}:${AMOUNT} \\\n      --fee_rate 1.5 \\\n      --enable_rbf \\\n    | jq -r '.psbt')\necho \"$UNSIGNED_PSBT\" &gt; frost-to-reg.psbt\n</code></pre> <p>The PSBT should look something like this:</p> <pre><code>cat frost-to-reg.psbt\n\ncHNidP8BAH0CAAAAAU+GpYAYGylD7Aq8iCEbUe8tDj6Ubk9drEryZb+IUR/xAQAAAAD9////AnHopDUAAAAAIlEgFs9vu6vPBwD8EBesRxbdwciiciVtZq09kN40zOY7kYoA4fUFAAAAABYAFBViDlLjJ0fOX2EzxHimbQ9MArg2ZgAAAAABASsAypo7AAAAACJRICE+aOPQcevOnEkRFNy9we527T9Ssw8FtfJ9Nvb983yFIRZRBsC8uQO6A1h6+/LHabL87iyFGKw4P/CEmr1r9Gun6wUAuwK1jAEXIFEGwLy5A7oDWHr78sdpsvzuLIUYrDg/8ISavWv0a6frAAEFIFEGwLy5A7oDWHr78sdpsvzuLIUYrDg/8ISavWv0a6frAQYlAMAiIFEGwLy5A7oDWHr78sdpsvzuLIUYrDg/8ISavWv0a6frrCEHUQbAvLkDugNYevvyx2my/O4shRisOD/whJq9a/Rrp+slAWSQs+DhhYkKIfKdulcJ3Mk78IJyclunm7g4b6KrBgJduwK1jAAA\n</code></pre> <p>:book: What is a PSBT? A PSBT is a Partially Signed Bitcoin Transaction. The format was introduced in 2018 in Bitcoin Core 0.17 and is defined in BIP 174. A PSBT divides up the creation of a transaction and the signing of the transaction, allowing the transaction to be passed around while it's unsigned or partially signed. This enables offline signatures and also supports multisigs, such as FROST group signatures.</p> <p>With a PSBT in hand, you now just need to sign it, which is the whole point of this exercise.</p>"},{"location":"04_2_Signing_PSBTs_with_FROST/#step-8-generating-a-signature-using-the-frost-group","title":"Step 8: Generating a Signature using the FROST Group","text":"<p>To sign a Bitcoin transaction, the first thing you have to do is extract the sighash from the PSBT. This is done with the <code>sighash-helper</code> tool that you built in \u00a74.1:</p> <pre><code>MSG=$(sighash-helper &lt; frost-to-reg.psbt)\n</code></pre> <p>:book: What is a Sighash? When Bitcoin signs a transaction, it actually signs a hash of the transaction: the sighash. Each transaction has multiple inputs (where funds are coming from) and multiple outputs (where funds are going to). Whether a sighash contains all, some, or none of the inputs and all, some, or none of the outputs is determined by a specific <code>sighash</code> flag, which is applied to each signature.</p> <p>You're now ready to use the ZF FROST <code>server</code> to sign your message, using the same procedure as \u00a73.2.</p> <p>In short:</p> <p>If you're already running the <code>frostd</code> server, kill it, to clear out any previous sessions. Then, restart <code>frostd</code></p> <pre><code>% frostd  --tls-cert localhost+3.pem --tls-key localhost+3-key.pem\n</code></pre> <p>Have Alice start the<code>coordinator</code> with a selected threshold of FROST group members and the sighash as the message input (sent here from the stdin, as shown with the <code>-m -</code> argument):</p> <pre><code>SIGNERS=\"$ALICE_PUBKEY,$BOB_PUBKEY\"\nprintf '%s\\n' \"$MSG\" | frost-client coordinator \\\n  --group \"$GROUP_ID\" \\\n  -s https://127.0.0.1:2744 \\\n  -S \"$SIGNERS\" \\\n  -m - \\\n  -o sig.raw \\\n  -c alice.toml\n</code></pre> <p>:information_source: NOTE: Obviously, you're again using the secp256k1-tr as a ciphersuite here, this time for signing. However, when the signing shares are brought together in round 2 of the signing process, you also take advantage of the other Blockchain Commons update to the ZF FROST tools: they're aggregated with a Taproot tweak.</p> <p>:book: What is a Taproot tweak? A P2TR Bitcoin script combines two elements: a locking script for a Schnorr signature and a tagged hash of a Merkle tree which contains additional ways in which the script may be unlocked. (This is the power of Taproot: traditional key access and script access are combined in a single package.) The tagged Merkle tree hash is simply added to the address thanks to the power of Schnorr aggregation. This is a \"tweak\". To sign then requires that the exact same tweak (e.g., the tagged Merkle tree hash) be added to one of the signing shares, to make the signature valid for the tweaked keys expected by Taproot. This happens as part of the signing process.</p> <p>Then each signer (including Alice) must join as a participant.</p> <p>Here's Alice doing so:</p> <pre><code>frost-client participant \\\n  --group \"$GROUP_ID\" \\\n  -s https://127.0.0.1:2744 \\\n  -c alice.toml\n</code></pre> <p>Here's Bob:</p> <pre><code>frost-client participant \\\n  --group \"$GROUP_ID\" \\\n  -s https://127.0.0.1:2744 \\\n  -c bob.toml\n</code></pre> <p>Each participant will see status updates and eventually be asked to sign:</p> <pre><code>Logging in...\nJoining signing session...\nSending commitments to coordinator...\nWaiting for coordinator to send signing package.................\nSigning package received\nMessage to be signed (hex-encoded):\ne24d7fad36af7e9e2fa2ecfaacc9e1cd3cadc19853ffc9bebf8787b19d02a305\nDo you want to sign it? (y/n)\n</code></pre> <p>But here's a puzzle! How do they know they're signing the right thing, as they can't backtrack a hash, which is what they're being asked to sign!</p> <p>The best practices methodology would be for Alice to send around the PSBT prior to initiating the FROST signing session.</p> <p>Ideally, each user could do a simple check with <code>bitcoin-cli</code>:</p> <pre><code>bitcoin-cli -rpcuser=$RPC_USER \\\n                            -rpcpassword=$RPC_PASS \\\n                            -regtest \\\n                            decodepsbt psbt=`cat frost-to-reg.psbt`\n</code></pre> <p>However, tests suggest that this doesn't work correctly at the time of this writing. However, sites such as chainquery allow for testing of the RPC in a more robust environment. A JSON of the entire transaction should appear.</p> <p>The users would want to consult the inputs and outputs to make sure the right money is being sent to the right places. Afterward, they could each run <code>sighash-helper</code> to verify the hash of the PSBT they examined matched the hash they're signing. Then, they can give their OK for signature with their FROST share.</p> <p>(Yes, this is another place where the actual process would need to be much improved to make it accessible for real-life usage. Developers take note!)</p>"},{"location":"04_2_Signing_PSBTs_with_FROST/#step-9-signing-the-psbt-using-the-frost-group","title":"Step 9: Signing the PSBT using the FROST Group","text":"<p>You've got a signature, you've now just got to attach it to the PSBT and send it out to the network.</p> <p>First, you should grab the hex of the signature:</p> <pre><code>SIG_HEX=$(xxd -p sig.raw | tr -d '\\n')\n</code></pre> <p>It should look something like this:</p> <pre><code>0842a58b3072175540b587b94763ef967db3c9ad48a7cecf6ff788595e049528638b08c1a7c07fbe025956e938bb92ce1e26bbcfacc78a68f49195381c27148a\n</code></pre> <p>Next, you need to attach the signature to the PSBT. This is the other place where neither <code>bitcoin-cli</code> or <code>bdk-cli</code> had sufficient functionality. That's because they both expect you to do signing with their tool, where you instead signed with a FROST tool.</p> <p>That's where the <code>psbt-sig-attach</code> helper comes into play. If you look at the code for the tool, you'll see that it attaches the signature to the 0th UTXO (input) of your transaction and flags it with the <code>SIGHASH_ALL</code> flag, meaning that the signature applies to all inputs and outputs.</p> <p>Here's how it's used. You just pipe the PSBT file into the <code>psbt-sig-attach</code> tool, and offer the signature as an argument.</p> <pre><code>SIGNED_PSBT=$(cat frost-to-reg.psbt | psbt-sig-attach \"$SIG_HEX\")\necho \"$SIGNED_PSBT\" &gt; frost-to-reg.signed.psbt\n</code></pre> <p>You'll now have a PSBT that is somewhat longer because it includes a signature. But, unlike the ECDSA signatures that were typically used on Bitcoin, this Schnorr (FROST) signature doesn't grow in size with the number of signers. This group signature, signed by both Alice and Bob, is exactly the same size as a signature made by one person!  And so the PSBT file is the same size as well! (That's one of the advantages of FROST).</p> <pre><code>cHNidP8BAH0CAAAAAU+GpYAYGylD7Aq8iCEbUe8tDj6Ubk9drEryZb+IUR/xAQAAAAD9////AnHopDUAAAAAIlEgFs9vu6vPBwD8EBesRxbdwciiciVtZq09kN40zOY7kYoA4fUFAAAAABYAFBViDlLjJ0fOX2EzxHimbQ9MArg2ZgAAAAABASsAypo7AAAAACJRICE+aOPQcevOnEkRFNy9we527T9Ssw8FtfJ9Nvb983yFARNACEKlizByF1VAtYe5R2Pvln2zya1Ip87Pb/eIWV4ElShjiwjBp8B/vgJZVuk4u5LOHia7z6zHimj0kZU4HCcUiiEWUQbAvLkDugNYevvyx2my/O4shRisOD/whJq9a/Rrp+sFALsCtYwBFyBRBsC8uQO6A1h6+/LHabL87iyFGKw4P/CEmr1r9Gun6wABBSBRBsC8uQO6A1h6+/LHabL87iyFGKw4P/CEmr1r9Gun6wEGJQDAIiBRBsC8uQO6A1h6+/LHabL87iyFGKw4P/CEmr1r9Gun66whB1EGwLy5A7oDWHr78sdpsvzuLIUYrDg/8ISavWv0a6frJQFkkLPg4YWJCiHynbpXCdzJO/CCcnJbp5u4OG+iqwYCXbsCtYwAAA==\n</code></pre>"},{"location":"04_2_Signing_PSBTs_with_FROST/#step-10-finalizing-and-sending-the-psbt","title":"Step 10: Finalizing and Sending the PSBT","text":"<p>You can now ask <code>bdk-cli</code> to close out the PSBT and prepare it for transmission:</p> <pre><code>FINAL_PSBT=$(bdk-cli \\\n  --network \"$NETWORK\" \\\n  --datadir \"$FROST_DIR\" \\\n  wallet \\\n    --client-type rpc \\\n    --url \"$RPC_URL\" \\\n    -a \"$RPC_AUTH\" \\\n    --database-type sqlite \\\n    --ext-descriptor \"$FROST_EXT_DESC\" \\\n    --int-descriptor \"$FROST_INT_DESC\" \\\n    finalize_psbt $(&lt; frost-to-reg.signed.psbt) \\\n  | jq -r '.psbt')\n</code></pre> <p>You can then broadcast it as a transmission:</p> <pre><code>TXID=$(bdk-cli \\\n  --network \"$NETWORK\" \\\n  --datadir \"$FROST_DIR\" \\\n  wallet \\\n    --client-type rpc \\\n    --url \"$RPC_URL\" \\\n    -a \"$RPC_AUTH\" \\\n    --database-type sqlite \\\n    --ext-descriptor \"$FROST_EXT_DESC\" \\\n    --int-descriptor \"$FROST_INT_DESC\" \\\n    broadcast \\\n      --psbt \"$FINAL_PSBT\" | \\\n    jq -r '.txid')\n</code></pre> <p>Since you're on regtest, you'll then need to advance a block:</p> <pre><code>bitcoin-cli -rpcuser=$RPC_USER \\\n        -rpcpassword=$RPC_PASS \\\n            -regtest \\\n            -generate 1\n</code></pre> <p>Afterward, you can verify your balances.</p> <p>Here's the Bitcoin wallet:</p> <pre><code>bitcoin-cli -rpcuser=$RPC_USER -rpcpassword=$RPC_PASS -regtest getbalance\n\n140.99999835\n</code></pre> <p>That's 89.99999835 + 50 (new coinbase award for new block) +1 (transfer).</p> <p>You can similarly sync and check the balance of your FROST wallet with <code>bdk-cli</code>.</p> <pre><code>bdk-cli \\\n  --network \"$NETWORK\" \\\n  --datadir \"$FROST_DIR\" \\\n  wallet \\\n    --client-type rpc \\\n    --database-type sqlite \\\n    --url \"$RPC_URL\" \\\n    -a \"$RPC_AUTH\" \\\n    --ext-descriptor \"$FROST_EXT_DESC\" \\\n    --int-descriptor \"$FROST_INT_DESC\" \\\n    sync\n\nbdk-cli \\\n  --network \"$NETWORK\" \\\n  --datadir \"$FROST_DIR\" \\\n  wallet \\\n    --client-type rpc \\\n    --database-type sqlite \\\n    --url \"$RPC_URL\" \\\n    -a \"$RPC_AUTH\" \\\n    --ext-descriptor \"$FROST_EXT_DESC\" \\\n    --int-descriptor \"$FROST_INT_DESC\" \\\n    balance\n</code></pre> <p>The result is:</p> <pre><code>{\n  \"satoshi\": {\n    \"confirmed\": 899999857,\n    \"immature\": 0,\n    \"trusted_pending\": 0,\n    \"untrusted_pending\": 0\n  }\n}\n</code></pre> <p>That's the 10 BTC minus the 1 BTC returned and the transaction fee.</p> <p>Congrats, you've proven a use case for FROST signing by signing a Bitcoin transaction! (Now get out there and design an easier way to do so!)</p>"},{"location":"04_2_Signing_PSBTs_with_FROST/#summary-signing-psbts-with-frost","title":"Summary: Signing PSBTs with FROST","text":"<p>Though it took ten steps here, the first six steps of this demo were just setting things up so that you had a regular Bitcoin wallet and a FROST Bitcoin wallet and the FROST Bitcoin wallet had funds.</p> <p>Fundamentally, all that's required to sign a PSBT with FROST is:</p> <ol> <li>Create an unsigned PSBT for the transaction.</li> <li>Extract the <code>sighash</code> from the PSBT.</li> <li>Use FROST Tools to sign the <code>sighash</code> for the transaction.</li> <li>Insert the signature into the transaction.</li> <li>Finalize &amp; send the transaction.</li> </ol>"},{"location":"04_2_Signing_PSBTs_with_FROST/#whats-next","title":"What's Next","text":"<p>That's it! We're considering expanding this tutorial in the future, per our TODO, as Blockchain Commons has technologies such as Gordian Clubs and Gordian Envelope that provide other use cases for FROST, as well as tools such as Hubert that can support FROST.</p> <p>But for the moment, you've got all the fundamentals of FROST, and should be ready to begin your own design.</p> <p>If you have questions or disagreements, please feel free to file Issues and if you have corrections, particularly simple things like typos, please file PRs.</p>"}]}